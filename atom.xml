<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stouyx&#39;s blog</title>
  
  <subtitle>keep doing！</subtitle>
  <link href="https://xadmc.gitee.io/stouyx/atom.xml" rel="self"/>
  
  <link href="https://xadmc.gitee.io/stouyx/"/>
  <updated>2024-04-24T15:15:42.199Z</updated>
  <id>https://xadmc.gitee.io/stouyx/</id>
  
  <author>
    <name>Wang Yuxuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希表1</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/02/04/%E5%93%88%E5%B8%8C%E8%A1%A81/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/02/04/%E5%93%88%E5%B8%8C%E8%A1%A81/</id>
    <published>2024-02-04T05:31:29.000Z</published>
    <updated>2024-04-24T15:15:42.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h1><p>建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。  </p><p>什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。  这句话很重要，大家在做哈希表题目都要思考这句话。 </p><p>文章讲解：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a>  </p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h1><p>建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。 </p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</a> </p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false</p><p>是否出现或者出现次数-&gt;哈希表 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        int re[26]=&#123;0&#125;;</span><br><span class="line">        for(int i = 0;i&lt;s.size();i++)&#123;</span><br><span class="line">            re[s[i]-&#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i&lt;t.size();i++)&#123;</span><br><span class="line">            re[t[i]-&#x27;a&#x27;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i&lt;26;i++)&#123;</span><br><span class="line">            if(re[i]!=0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p>建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。 </p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</a>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果，之所以用set是为了给结果集去重</span><br><span class="line">        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            //遍历容器中的每一个元素</span><br><span class="line">            // 发现nums2的元素 在nums_set里又出现过</span><br><span class="line">            if (nums_set.find(num) != nums_set.end()) &#123;</span><br><span class="line">            //find 函数，假如找到了num，则返回指向num的迭代器，假如没找到，则返回最后一个元素之后的位置，即.end()</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>涉及STL</p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><p>建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子 </p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html</a>  </p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。 </p><p>建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。 </p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</a> </p>]]></content>
    
    
    <summary type="html">哈希表初步</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>链表2</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/02/03/%E9%93%BE%E8%A1%A82/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/02/03/%E9%93%BE%E8%A1%A82/</id>
    <published>2024-02-03T05:31:29.000Z</published>
    <updated>2024-04-24T14:35:46.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p>用虚拟头结点，这样会方便很多。 </p><p>本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com0024.两两交换链表中的节点.html/">https://programmercarl.com0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</a></p><p>状态：刚开始看题我想用双指针法去解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        ListNode* dummy_head = new ListNode(0);</span><br><span class="line">        dummy_head-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        //有了只有知道当前结点位置，才能操作下两个结点</span><br><span class="line">        while(cur-&gt;next != nullptr&amp;&amp;cur-&gt;next-&gt;next != nullptr)&#123;</span><br><span class="line">        //要先写cur-&gt;next，否则可能先访问空指针的next</span><br><span class="line">            ListNode* t = cur-&gt;next;</span><br><span class="line">            ListNode* t1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            //要记录下两个指针的位置，修改指向后会丢失方向</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = t;</span><br><span class="line">            t-&gt;next = t1;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p>双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</a></p><p>双指针法，两个指针之间间隔N+1的长度，这样慢指针指向要删除的结点的前一个结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        ListNode* dummy_head = new ListNode(0);</span><br><span class="line">        dummy_head-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummy_head;</span><br><span class="line">        ListNode* slow = dummy_head;</span><br><span class="line">        while((n+1)!=0&amp;&amp;fast!=nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast!=nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* t = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        delete t;</span><br><span class="line">        return dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h1><p>本题没有视频讲解，大家注意 数值相同，不代表指针相同。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html</a></p><p>没有想到利用长度差来处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        int lenA = 0, lenB = 0;</span><br><span class="line">        while (curA != NULL) &#123; // 求链表A的长度</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (curB != NULL) &#123; // 求链表B的长度</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        // 让curA为最长链表的头，lenA为其长度</span><br><span class="line">        if (lenB &gt; lenA) &#123;</span><br><span class="line">            swap (lenA, lenB);</span><br><span class="line">            swap (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        // 求长度差</span><br><span class="line">        int gap = lenA - lenB;</span><br><span class="line">        // 让curA和curB在同一起点上（末尾位置对齐）</span><br><span class="line">        while (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历curA 和 curB，遇到相同则直接返回</span><br><span class="line">        while (curA != NULL) &#123;</span><br><span class="line">            if (curA == curB) &#123;</span><br><span class="line">                return curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h1><p>算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</a></p><p>题目有难度第一次看的时候没有头绪</p><p>利用双指针法来判断有没有环<br>快指针每次走两个结点<br>慢指针每次走一个结点<br>相当于每次缩短一个结点的距离，不会在环中错过<br>如果差值不是一个结点就可能错过</p>]]></content>
    
    
    <summary type="html">链表深化</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>链表1</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/01/31/%E9%93%BE%E8%A1%A81/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/01/31/%E9%93%BE%E8%A1%A81/</id>
    <published>2024-01-31T11:00:30.000Z</published>
    <updated>2024-04-24T14:35:28.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p>建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：：<a href="https://programmercarl.com0203.移除链表元素.html/">https://programmercarl.com0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html</a></p><p>状态：自己写完之后总是数组访问越界</p><p>方法：</p><ol><li>分为头结点与普通结点进行处理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        while (head!=NULL&amp;&amp;head-&gt;val==val) &#123;</span><br><span class="line">            ListNode* t = head;//存储要删除的位置</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            delete t;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur;//头结点不动，用临时指针去代表头结点</span><br><span class="line">        cur = head;//此时头结点可能为空</span><br><span class="line">        while (cur!=NULL&amp;&amp;cur-&gt;next!=NULL) &#123;//所以要检测该结点是否为空</span><br><span class="line">            if (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* t = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                delete t;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>用虚拟头结点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* dummy_head = new ListNode(0);</span><br><span class="line">        dummy_head-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        while (cur-&gt;next!=NULL) &#123;</span><br><span class="line">            if (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* t = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                delete t;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy_head-&gt;next;//原来的head可能已经被删除，此时不能返回head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h1><p>建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com0707.设计链表.html/">https://programmercarl.com0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    struct LinkNode</span><br><span class="line">    &#123;</span><br><span class="line">        int val;</span><br><span class="line">        LinkNode* next;</span><br><span class="line">        LinkNode(int val):val(val),next(nullptr)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        dummy_head = new LinkNode(0);</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        if (index&gt;(size-1)||index&lt;0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummy_head-&gt;next;//根据需要来设置cur的位置</span><br><span class="line">        int n = index;</span><br><span class="line">        while (n) &#123;//根据cur的位置来设置循环条件</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        LinkNode* newNode = new LinkNode(val);</span><br><span class="line">        newNode-&gt;next = dummy_head-&gt;next;</span><br><span class="line">        dummy_head-&gt;next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        LinkNode* newNode = new LinkNode(val);</span><br><span class="line">        LinkNode* cur = dummy_head;</span><br><span class="line">        while (cur-&gt;next!=nullptr) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if (index&gt;size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index&lt;0) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* newNode = new LinkNode(val);</span><br><span class="line">        LinkNode* cur = dummy_head;</span><br><span class="line">        while (index) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        if (index&lt;0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index&gt;=size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummy_head;</span><br><span class="line">        while (index) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        delete t;</span><br><span class="line">        t = nullptr;</span><br><span class="line">        //delete命令指示释放了tmp指针原本所指的那部分内存，</span><br><span class="line">        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span><br><span class="line">        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span><br><span class="line">        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int size;</span><br><span class="line">    LinkNode* dummy_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com0206.翻转链表.html/">https://programmercarl.com0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</a> </p><ol><li>双指针写法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = nullptr;</span><br><span class="line">        while(cur)&#123;//cur为nullptr的时候循环终止</span><br><span class="line">            ListNode* t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>递归写法</li></ol><p>严格按照双指针写法来的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;</span><br><span class="line">        if(cur == NULL) return pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br><span class="line">        // pre = cur;</span><br><span class="line">        // cur = temp;</span><br><span class="line">        return reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        // 和双指针法初始化是一样的逻辑</span><br><span class="line">        // ListNode* cur = head;</span><br><span class="line">        // ListNode* pre = NULL;</span><br><span class="line">        return reverse(NULL, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">链表简单操作</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数组3</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/01/26/%E6%95%B0%E7%BB%843/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/01/26/%E6%95%B0%E7%BB%843/</id>
    <published>2024-01-26T04:00:30.000Z</published>
    <updated>2024-04-24T15:16:54.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>题目建议： 本题关键在于理解双指针思想 </p><p>题目链接：<br><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a><br>文章讲解：<br><a href="https://programmercarl.com0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B%E6%96%B9.html">https://programmercarl.com0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B%E6%96%B9.html</a><br>视频讲解：<br><a href="https://www.bilibili.com/video/BV1QB4y1D7ep">https://www.bilibili.com/video/BV1QB4y1D7ep</a> </p><p>状态：第一次看就是先平方再用冒泡排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for (int i = 0 ; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            nums[i] = pow(nums[i], 2);</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        int t;</span><br><span class="line">        for(i=0;i&lt;nums.size();i++)</span><br><span class="line">           &#123;</span><br><span class="line">               for(j=0;j&lt;nums.size()-1-i;j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   if(nums[j]&gt;nums[j+1])</span><br><span class="line">                   &#123;</span><br><span class="line">                       t=nums[j];</span><br><span class="line">                       nums[j]=nums[j+1];</span><br><span class="line">                       nums[j+1]=t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; result(nums.size(), 0);</span><br><span class="line">        int k = nums.size()-1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = nums.size()-1;</span><br><span class="line">        for (; i&lt;=j;) &#123;</span><br><span class="line">            if (nums[i]*nums[i]&gt;nums[j]*nums[j]) &#123;</span><br><span class="line">                result[k--] = nums[i]*nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                result[k--] = nums[j]*nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。 </p><p>题目链接：<br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a><br>文章讲解：<br><a href="https://programmercarl.com0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%9%E6%95%B0%E7%BB%84.html">https://programmercarl.com0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%9%E6%95%B0%E7%BB%84.html</a><br>视频讲解：<br><a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">https://www.bilibili.com/video/BV1tZ4y1q7XE</a></p><p>状态：第一反应没有想到双指针；</p><p>双指针动态更新窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int res = INT32_MAX;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int subL;</span><br><span class="line">        for (int j = 0; j&lt;nums.size(); j++) &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            while (sum&gt;=target) &#123;</span><br><span class="line">                subL = j-i+1;</span><br><span class="line">                res = min(subL, res);</span><br><span class="line">                sum-=nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == INT32_MAX ? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p>题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 </p><p>题目链接：<br><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a><br>文章讲解：<br><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html</a><br>视频讲解：<br><a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">https://www.bilibili.com/video/BV1SL4y1N7mV/</a></p><p>重点还是理解循环不变量，利用区间的定义，例如左闭右开，左开右闭区间的思想去处理循环，参考二分查找</p><p>状态：自己写的时候还是感觉有些难，边界条件考虑不到位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组</span><br><span class="line">        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置</span><br><span class="line">        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span><br><span class="line">        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br><span class="line">        int count = 1; // 用来给矩阵中每一个空格赋值</span><br><span class="line">        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span><br><span class="line">        int i,j;</span><br><span class="line">        while (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            // 下面开始的四个for就是模拟转了一圈</span><br><span class="line">            // 模拟填充上行从左到右(左闭右开)</span><br><span class="line">            for (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 模拟填充右列从上到下(左闭右开)</span><br><span class="line">            for (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 模拟填充下行从右到左(左闭右开)</span><br><span class="line">            for (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 模拟填充左列从下到上(左闭右开)</span><br><span class="line">            for (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            // offset 控制每一圈里每一条边遍历的长度</span><br><span class="line">            offset += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br><span class="line">        if (n % 2) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组进一步深化</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数组2</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/01/25/%E6%95%B0%E7%BB%842/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/01/25/%E6%95%B0%E7%BB%842/</id>
    <published>2024-01-25T07:30:22.000Z</published>
    <updated>2024-04-24T15:16:48.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>题目链接：<br><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a> </p><p>文章讲解：<br><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</a></p><p>视频讲解：<br><a href="https://www.bilibili.com/video/BV12A4y1Z7LP">https://www.bilibili.com/video/BV12A4y1Z7LP</a></p><p>状态：第一次看题想要用两层循环去解决</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>时间复杂度O(n^2);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i&lt;size; i++) &#123;</span><br><span class="line">            if(nums[i] == val)&#123;</span><br><span class="line">                for (int j = i+1; j&lt;size; j++) &#123;</span><br><span class="line">                //j=i的话 有nums[j] 保证其不越界 j要小于size</span><br><span class="line">                    nums[j-1] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i&lt;size; i++) &#123;</span><br><span class="line">            if(nums[i] == val)&#123;</span><br><span class="line">                for (int j = i; j&lt;size-1; j++) &#123;</span><br><span class="line">                //j=i的话 有nums[j+1] 保证其不越界 j要小于size-1</span><br><span class="line">                    nums[j] = nums[j+1];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>时间复杂度O(n);</p><p>快指针用于获取新的数据，然后检查新的数据是否满足要求<br>满足要求的话就赋值给慢指针，然后慢指针后移一位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast&lt;nums.size(); fast++) &#123;</span><br><span class="line">            if(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">暴力解法与双指针</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数组1</title>
    <link href="https://xadmc.gitee.io/stouyx/2024/01/24/%E6%95%B0%E7%BB%841/"/>
    <id>https://xadmc.gitee.io/stouyx/2024/01/24/%E6%95%B0%E7%BB%841/</id>
    <published>2024-01-24T05:20:21.000Z</published>
    <updated>2024-04-24T14:35:42.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>题目链接：<br><a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a><br>文章讲解：<br><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</a><br>视频讲解：<br><a href="https://www.bilibili.com/video/BV1fA4y1o715">https://www.bilibili.com/video/BV1fA4y1o715</a></p><p>状态：之前只了解过二分查找的过程，上手写才知道有这么多细节需要注意，<br>如果有重复元素的话应该会更复杂</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的边界确定，与数组的定义一一对应，根据数组来确定边界</p><h2 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h2><p>[left,right]<br>此时 left 与 right 都在区间中，而且 left &#x3D; right 可以成立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0;//包含左区间，从0开始</span><br><span class="line">    int right = nums.size()-1;//包含右区间，从尾下标开始</span><br><span class="line">    while (left&lt;=right) &#123;  </span><br><span class="line">    //left = right 可以成立，所以有等于号</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        if (nums[mid]&lt;target) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">            //包含左边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[mid]&gt;target) &#123;</span><br><span class="line">            right = mid-1;</span><br><span class="line">            //包含右边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h2><p>[left,right)<br>此时 left 在区间中，right 不在区间中，而且 left &#x3D; right 不成立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0;//包含左区间，从0开始</span><br><span class="line">    int right = nums.size();//不包含右区间，从尾下标的下一个开始</span><br><span class="line">    while (left&lt;right) &#123;  </span><br><span class="line">    //left = right 不成立，不能有等于号</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        if (nums[mid]&lt;target) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">            //包含左边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[mid]&gt;target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            //不包含右边界，所以可以保留mid</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找边界问题处理</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树算法</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/12/04/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/12/04/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2023-12-04T12:20:36.000Z</published>
    <updated>2024-01-02T14:18:13.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>Prim算法是一种用来构建最小生成树的贪婪算法，通常用于带有权重的连通图中。它从一个初始顶点开始，逐步扩展最小生成树，每次选择连接已选定顶点集合和未选定顶点集合的边中权重最小的边，将新的顶点加入已选定的顶点集合，直到所有顶点都被包含在最小生成树中。</p><p>Prim算法的步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Prim(G, d[])</span><br><span class="line">&#123;</span><br><span class="line">初始化;</span><br><span class="line">for(循环n次)</span><br><span class="line">&#123;</span><br><span class="line">u = 使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">记u已被访问;</span><br><span class="line">for(从u出发能到达的所有顶点v)</span><br><span class="line">&#123;</span><br><span class="line">if(v未被访问 &amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)</span><br><span class="line">&#123;</span><br><span class="line">将G[u][v]赋值给v与集合S的最短距离d[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define V 5 // 假设图有5个顶点</span><br><span class="line"></span><br><span class="line">int minKey(int key[], bool mstSet[]) &#123;</span><br><span class="line">    int min = INT_MAX, min_index;</span><br><span class="line"></span><br><span class="line">    for (int v = 0; v &lt; V; v++) &#123;</span><br><span class="line">        if (mstSet[v] == false &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            min = key[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printMST(int parent[], int graph[V][V]) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;边\t权重\n&quot;;</span><br><span class="line">    for (int i = 1; i &lt; V; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; &quot; - &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; graph[i][parent[i]] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void primMST(int graph[V][V]) &#123;</span><br><span class="line">    int parent[V]; // 存放构建的最小生成树</span><br><span class="line">    int key[V]; // 存放选择的顶点到最小生成树的最小权重</span><br><span class="line"></span><br><span class="line">    bool mstSet[V]; // 用于判断顶点是否在最小生成树中</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; V; i++) &#123;</span><br><span class="line">        key[i] = INT_MAX;</span><br><span class="line">        mstSet[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key[0] = 0; // 从第一个顶点开始构建</span><br><span class="line"></span><br><span class="line">    parent[0] = -1; // 根节点没有父节点</span><br><span class="line"></span><br><span class="line">    for (int count = 0; count &lt; V - 1; count++) &#123;</span><br><span class="line">        int u = minKey(key, mstSet);</span><br><span class="line"></span><br><span class="line">        mstSet[u] = true;</span><br><span class="line"></span><br><span class="line">        for (int v = 0; v &lt; V; v++) &#123;</span><br><span class="line">            if (graph[u][v] &amp;&amp; mstSet[v] == false &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                key[v] = graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMST(parent, graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int graph[V][V] = &#123;</span><br><span class="line">        &#123;0, 2, 0, 6, 0&#125;,</span><br><span class="line">        &#123;2, 0, 3, 8, 5&#125;,</span><br><span class="line">        &#123;0, 3, 0, 0, 7&#125;,</span><br><span class="line">        &#123;6, 8, 0, 0, 9&#125;,</span><br><span class="line">        &#123;0, 5, 7, 9, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    primMST(graph);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Prim算法可以使用堆或优先队列来存储和处理边的信息，以便快速找到权重最小的边。它的时间复杂度通常为 O(ElogV)，其中 V 是顶点数，E 是边数，这使得Prim算法在处理大型图时效率较高。</p><h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>Kruskal算法也是用来构建最小生成树的一种贪婪算法，它与Prim算法不同的是，Kruskal算法是基于边来构建最小生成树的。</p><p>Kruskal算法的步骤如下：</p><p>初始化：将图中的每个顶点看作是一个独立的树（单独的集合），将所有边按照权重从小到大进行排序。</p><p>重复以下步骤，直到形成最小生成树：</p><p>从已排序的边中选择权重最小的边。<br>如果这条边连接的两个顶点属于不同的树（不在同一个集合中），则将这两个树合并成一棵树，即将这两个顶点所在的集合合并。<br>如果这条边连接的两个顶点已经在同一棵树中，则舍弃这条边，以避免形成环路。<br>当最小生成树中包含了图中的所有顶点时，算法结束。</p><p>Kruskal算法不断选择权重最小的边，并通过并查集等数据结构来维护顶点的连通性。它会避免形成环路，并确保生成的树是一个连通树。与Prim算法相比，Kruskal算法不需要选择一个初始顶点，它更侧重于边的选择和集合的合并。</p><p>Kruskal算法的时间复杂度通常为 O(ElogE)，其中 E 是边数。它适用于稀疏图（边数相对较少）的情况下，效率较高。</p>]]></content>
    
    
    <summary type="html">Prim算法 Kruskal算法</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Minimax算法</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/12/04/Minimax/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/12/04/Minimax/</id>
    <published>2023-12-04T11:20:36.000Z</published>
    <updated>2023-12-04T12:04:15.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法具体内容"><a href="#算法具体内容" class="headerlink" title="算法具体内容"></a>算法具体内容</h1><p>Minimax算法是一种常用于回合制游戏的决策树搜索算法，用于在有限的游戏状态树中找到最佳决策。它通过递归地评估游戏状态来模拟所有可能的走法，最大化自己的利益并最小化对手的利益。</p><p>该算法基于以下两个基本概念：</p><p>Maximize（最大化）： 在玩家自己的回合，尝试选择最有利于自己的走法。</p><p>Minimize（最小化）： 在对手的回合，尝试选择最不利于自己的走法，即最有利于对手的走法。</p><p>Minimax算法的核心思想是递归地生成游戏状态树，并根据当前玩家的角色（最大化还是最小化）来选择对应的最优走法。它通过评估每个可能的走法，并选择能够导致最有利结果的走法。</p><p>在实现Minimax算法时，通常会使用递归函数来模拟游戏状态的展开和评估。在棋类游戏中，例如井字棋，算法会评估每一步可能的移动，计算最终的得分，并选择能够最大化当前玩家利益的最佳走法。<br>Minimax算法通常用于模拟两个对手轮流进行决策的情况，默认自己为其中一个选手，而另一个为对手，其中一个玩家会尽力最大化自己的得分（Maximizer），而另一个玩家会尽力最小化对手的得分（Minimizer）。</p><p>在典型的Minimax算法中：</p><p>最大化玩家（Maximizer）努力寻找可以让自己得分最高的决策，即通过递归调用找到最大值。</p><p>最小化玩家（Minimizer）则努力寻找可以让最大化玩家得分最低的决策，即通过递归调用找到最小值。</p><p>在Minimax算法中，使用递归进行状态树的搜索，即尝试模拟每一个可能的走法，评估每个走法对最终结果的影响。为了模拟这些可能的走法，必须在递归调用中修改棋盘的状态，即将某个位置设置为当前玩家的棋子。但在递归调用结束后，需要将棋盘状态恢复，以便尝试其他可能的走法。</p><p>回溯确保了算法能够尝试所有可能的走法，并且在搜索完一条分支后，能够回到上一个状态，尝试其他分支。如果不进行回溯，可能会导致算法在搜索时无法正确模拟所有可能的情况，影响最终得出的最优决策。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Alice和Bob正在玩井字棋游戏。 井字棋游戏的规则很简单：两人轮流往3*3的棋盘中放棋子，Alice放的是“X”，Bob放的是“O”，Alice执先。当同一种棋子占据一行、一列或一条对角线的三个格子时，游戏结束，该种棋子的持有者获胜。当棋盘被填满的时候，游戏结束，双方平手。 <br>　　Alice设计了一种对棋局评分的方法： <br>　　- 对于Alice已经获胜的局面，评估得分为(棋盘上的空格子数+1)； <br>　　- 对于Bob已经获胜的局面，评估得分为 -(棋盘上的空格子数+1)； <br>　　- 对于平局的局面，评估得分为0；<br>　　例如上图中的局面，Alice已经获胜，同时棋盘上有2个空格，所以局面得分为2+1&#x3D;3。 <br>　　由于Alice并不喜欢计算，所以他请教擅长编程的你，如果两人都以最优策略行棋，那么当前局面的最终得分会是多少？ <br>csp 棋局评估</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;climits&gt; // 引入 INT_MAX</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line">int G[N][N]; // 井字棋盘面</span><br><span class="line"></span><br><span class="line">// 检查某个玩家是否胜利</span><br><span class="line">bool check(int player) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        // 检查行和列</span><br><span class="line">        if (G[i][0] == player &amp;&amp; G[i][1] == player &amp;&amp; G[i][2] == player) return true; // 检查行</span><br><span class="line">        if (G[0][i] == player &amp;&amp; G[1][i] == player &amp;&amp; G[2][i] == player) return true; // 检查列</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查对角线</span><br><span class="line">    if (G[0][0] == player &amp;&amp; G[1][1] == player &amp;&amp; G[2][2] == player) return true; // 检查对角线</span><br><span class="line">    if (G[0][2] == player &amp;&amp; G[1][1] == player &amp;&amp; G[2][0] == player) return true; // 检查对角线</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 评估当前局面得分</span><br><span class="line">int evaluate() &#123;</span><br><span class="line">    int emptySpaces = 0;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++)</span><br><span class="line">        for (int j = 0; j &lt; 3; j++)</span><br><span class="line">            if (G[i][j] == 0) emptySpaces++; // 统计剩余空格数</span><br><span class="line"></span><br><span class="line">    if (check(1)) return emptySpaces + 1; // 玩家 A 获胜</span><br><span class="line">    else if (check(2)) return -(emptySpaces + 1); // 玩家 B 获胜</span><br><span class="line">    else if (emptySpaces == 0) return 0; // 平局</span><br><span class="line">    else return INT_MAX; // 游戏未结束，使用 INT_MAX 表示无穷大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 Minimax 和 DFS 来计算局面得分</span><br><span class="line">int minimax(int player) &#123;</span><br><span class="line">    int score = evaluate();</span><br><span class="line">    if (score != INT_MAX) return score; // 已经可以确定胜负或平局，直接返回得分</span><br><span class="line"></span><br><span class="line">    if (player == 1) &#123;</span><br><span class="line">        int ans = -INT_MAX;</span><br><span class="line">        // 遍历所有可能的下一步走法</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (G[i][j] == 0) &#123; // 空格可以下子</span><br><span class="line">                    G[i][j] = 1; // 假设下子</span><br><span class="line">                    ans = max(ans, minimax(2)); // 递归调用，选取对手最差的情况</span><br><span class="line">                    G[i][j] = 0; // 回溯，恢复空格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        // 遍历所有可能的下一步走法</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (G[i][j] == 0) &#123; // 空格可以下子</span><br><span class="line">                    G[i][j] = 2; // 假设下子</span><br><span class="line">                    ans = min(ans, minimax(1)); // 递归调用，选取对手最好的情况</span><br><span class="line">                    G[i][j] = 0; // 回溯，恢复空格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        // 读入当前局面</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            for (int j = 0; j &lt; 3; j++)</span><br><span class="line">                cin &gt;&gt; G[i][j];</span><br><span class="line"></span><br><span class="line">        int res = minimax(1); // 玩家 A 先走</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">回合制游戏</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图的最短路径</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/12/04/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/12/04/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2023-12-04T10:20:36.000Z</published>
    <updated>2023-12-04T10:26:02.164Z</updated>
    
    <content type="html"><![CDATA[<img src="https://vip.helloimg.com/images/2023/12/04/oQdUpK.jpg" width="900%" height="100%"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int graph[][9], int weight[][9], int start, int end) &#123;</span><br><span class="line">    int dis[9];</span><br><span class="line">    int pre[9];</span><br><span class="line">    bool flag[9];</span><br><span class="line"></span><br><span class="line">    // 初始化数组</span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        dis[i] = INT_MAX;</span><br><span class="line">        pre[i] = -1;</span><br><span class="line">        flag[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[start] = 0;</span><br><span class="line">    flag[start] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        if (graph[start][i] == 1) &#123;</span><br><span class="line">            dis[i] = weight[start][i];</span><br><span class="line">            pre[i] = start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        int min = INT_MAX;</span><br><span class="line">        int min_rode = -1;</span><br><span class="line"></span><br><span class="line">        // 在没有最短路径标记的点中找到距离最小的节点</span><br><span class="line">        for (int j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">            if (!flag[j] &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                min_rode = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到路径最小点之后 遍历最小点的邻接点</span><br><span class="line">        if (min_rode != -1) &#123;</span><br><span class="line">            flag[min_rode] = true;</span><br><span class="line">            for (int k = 0; k &lt; 9; k++) &#123;</span><br><span class="line">                if (!flag[k] &amp;&amp; graph[min_rode][k] == 1 &amp;&amp; dis[min_rode] + weight[min_rode][k] &lt; dis[k]) &#123;</span><br><span class="line">                    dis[k] = dis[min_rode] + weight[min_rode][k];</span><br><span class="line">                    pre[k] = min_rode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出最短路径</span><br><span class="line">    cout &lt;&lt; &quot;从节点 &quot; &lt;&lt; start &lt;&lt; &quot; 到节点 &quot; &lt;&lt; end &lt;&lt; &quot; 的最短路径为：&quot; &lt;&lt; dis[end] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int graph[9][9] = &#123;</span><br><span class="line">        &#123;0, 1, 0, 0, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">        &#123;1, 0, 1, 0, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">        &#123;0, 1, 0, 1, 0, 1, 0, 0, 1&#125;,</span><br><span class="line">        &#123;0, 0, 1, 0, 1, 1, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 1, 0, 1, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 1, 1, 1, 0, 1, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 0, 0, 1, 0, 1, 1&#125;,</span><br><span class="line">        &#123;1, 1, 0, 0, 0, 0, 1, 0, 1&#125;,</span><br><span class="line">        &#123;0, 0, 1, 0, 0, 0, 1, 1, 0&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    int weight[9][9] = &#123;</span><br><span class="line">        &#123;0, 4, 0, 0, 0, 0, 0, 8, 0&#125;,</span><br><span class="line">        &#123;4, 0, 8, 0, 0, 0, 0, 11, 0&#125;,</span><br><span class="line">        &#123;0, 8, 0, 7, 0, 4, 0, 0, 2&#125;,</span><br><span class="line">        &#123;0, 0, 7, 0, 9, 14, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 9, 0, 10, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 4, 14, 10, 0, 2, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 0, 0, 2, 0, 1, 6&#125;,</span><br><span class="line">        &#123;8, 11, 0, 0, 0, 0, 1, 0, 7&#125;,</span><br><span class="line">        &#123;0, 0, 2, 0, 0, 0, 6, 7, 0&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = 4;</span><br><span class="line"></span><br><span class="line">    Dijkstra(graph, weight, start, end);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Dijkstra算法</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>new的理解</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/11/28/new%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/11/28/new%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2023-11-28T10:11:36.000Z</published>
    <updated>2023-11-28T15:40:51.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><h2 id="1-new可以直接返回一个指针"><a href="#1-new可以直接返回一个指针" class="headerlink" title="1.new可以直接返回一个指针"></a>1.new可以直接返回一个指针</h2><p>如果已经有一个 HuffmanNode 对象，可以创建指向它的指针，无需使用 new：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HuffmanNode node(10);  // 创建一个 HuffmanNode 对象</span><br><span class="line">HuffmanNode* pointer = &amp;node;  // 创建指向该对象的指针</span><br></pre></td></tr></table></figure><p>这里 pointer 是一个指向 node 对象的指针，而不是使用 new 分配内存创建的指针</p><p>如果要创建一个新的对象并且获得指向它的指针，通常情况下可以使用 new 操作符来动态分配内存并创建对象。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HuffmanNode* newNode = new HuffmanNode(20); </span><br></pre></td></tr></table></figure><p>这行代码会在堆内存中分配空间以存储一个 HuffmanNode 对象，并将其初始化为权值为 20，然后返回指向这个对象的指针 newNode<br>但是，在使用 new 创建对象后，务必记得在不需要这个对象时使用 delete 删除释放它所占用的内存，以免造成内存泄漏</p><h2 id="2-函数中new出来的变量可以跨函数使用"><a href="#2-函数中new出来的变量可以跨函数使用" class="headerlink" title="2.函数中new出来的变量可以跨函数使用"></a>2.函数中new出来的变量可以跨函数使用</h2><p>在函数中直接使用变量名声明的变量通常是局部变量，它们的作用域限定在该函数内部。一旦函数执行结束，这些局部变量所占用的内存空间会被释放掉，它们的生命周期也随之结束。</p><p>例如，在函数中这样声明变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunction() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当myFunction()执行完毕后，变量x将会被销毁，因为它是在函数内部声明的局部变量。这种变量的生命周期通常是在其所在的代码块结束时结束。</p><p>对于动态分配的内存，比如使用new来分配内存，所分配的内存空间并不会在函数结束时自动释放，而是需要显式地使用delete来释放。使用 new 运算符在堆（heap）上动态分配的内存空间可以跨函数使用。堆上分配的内存空间不受局部作用域的限制。这种情况下，即使函数结束，分配的内存仍然存在，除非显式释放。</p><p>因此，直接在函数中声明的变量，一般在函数结束时会被销毁。而使用动态分配内存的变量（通过new操作符），则需要手动释放分配的内存空间，否则可能会导致内存泄漏。</p>]]></content>
    
    
    <summary type="html">new的理解</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/23/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/23/%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2023-05-23T10:34:52.000Z</published>
    <updated>2023-05-23T10:37:01.428Z</updated>
    
    
    <summary type="html">排序算法：快速排序</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xadmc.gitee.io/stouyx/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2023-05-23T09:33:16.000Z</published>
    <updated>2023-05-23T10:36:40.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int a[n];</span><br><span class="line">int i,j,min,t;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">    min=i;</span><br><span class="line">    for(j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">        if(a[j]&lt;a[min])&#123;</span><br><span class="line">            min=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(min!=i)&#123;</span><br><span class="line">        t=a[min];</span><br><span class="line">        a[min]=a[i];</span><br><span class="line">        a[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int a[n];</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int i,j,t;</span><br><span class="line">    for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">    //n个数要比较n-1次</span><br><span class="line">        for(j=0;j&lt;n-i-1;j++)&#123;</span><br><span class="line">        //控制排序次数，已经排序好的不再参与排序</span><br><span class="line">            if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">                t=a[j];</span><br><span class="line">                a[j]=a[j+1];</span><br><span class="line">                a[j+1]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：<br>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p><p>以一个数组作为示例，取区间第一个数为基准数。</p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th>3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th></tr></thead><tbody><tr><td align="left"><u>72</u></td><td align="left">6</td><td align="left">57</td><td>88</td><td align="left">60</td><td align="left">42</td><td align="left">83</td><td align="left">73</td><td align="left">48</td><td align="left">85</td></tr></tbody></table><p>初始时，i &#x3D; 0;  j &#x3D; 9;   X &#x3D; a[i] &#x3D; 72<br>由于已经将 a[0] 中的数保存到 X 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。<br>从j开始向前找一个比X小或等于X的数。当j&#x3D;8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]&#x3D;a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i&#x3D;3，符合条件，将a[3]挖出再填到上一个坑中a[8]&#x3D;a[3]; j–;</p><p>数组变为：</p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th>3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th></tr></thead><tbody><tr><td align="left"><u>48</u></td><td align="left">6</td><td align="left">57</td><td><u>88</u></td><td align="left">60</td><td align="left">42</td><td align="left">83</td><td align="left">73</td><td align="left"><u>88</u></td><td align="left">85</td></tr></tbody></table><p>i &#x3D; 3;   j &#x3D; 7;   X&#x3D;72<br>再重复上面的步骤，先从后向前找，再从前向后找。<br>从j开始向前找，当j&#x3D;5，符合条件，将a[5]挖出填到上一个坑中，a[3] &#x3D; a[5]; i++;<br>从i开始向后找，当i&#x3D;5时，由于i&#x3D;&#x3D;j退出。<br>此时，i &#x3D; j &#x3D; 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。<br>数组变为：</p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th>3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th></tr></thead><tbody><tr><td align="left"><u>48</u></td><td align="left">6</td><td align="left">57</td><td><u>42</u></td><td align="left">60</td><td align="left"><u>72</u></td><td align="left">83</td><td align="left">73</td><td align="left"><u>88</u></td><td align="left">85</td></tr></tbody></table><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int s[], int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = left, j = right, key = s[left];</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">                j--;  </span><br><span class="line">            if(i &lt; j)&#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">                i++;  </span><br><span class="line">            if(i &lt; j)&#123;</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = key;</span><br><span class="line">        quick_sort(s, left, i - 1); // 递归调用 </span><br><span class="line">        quick_sort(s, i + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">排序算法：快速排序</summary>
    
    
    
    <category term="算法" scheme="https://xadmc.gitee.io/stouyx/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xadmc.gitee.io/stouyx/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>输入一行整数</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/22/%E8%BE%93%E5%85%A5%E4%B8%80%E8%A1%8C%E6%95%B4%E6%95%B0/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/22/%E8%BE%93%E5%85%A5%E4%B8%80%E8%A1%8C%E6%95%B4%E6%95%B0/</id>
    <published>2023-05-22T07:25:19.000Z</published>
    <updated>2023-05-22T07:27:50.909Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">int m[10000];</span><br><span class="line">int i=0;</span><br><span class="line">while (cin &gt;&gt; num) &#123;</span><br><span class="line">     m[i]=num;</span><br><span class="line">     i++;</span><br><span class="line">     if (cin.get() == &#x27;\n&#x27;) &#123;</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体深入理解cin函数</p>]]></content>
    
    
    <summary type="html">输入一行整数，如何自动生成int数组</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Mac软件无法打开</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/20/Mac%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/20/Mac%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</id>
    <published>2023-05-20T14:04:49.000Z</published>
    <updated>2023-05-20T14:36:18.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的三种报错方式"><a href="#常见的三种报错方式" class="headerlink" title="常见的三种报错方式"></a>常见的三种报错方式</h2><p>xxx已损坏，无法打开，你应该将它移到废纸篓解决办法<br>打不开 xxx，因为它来自身份不明的开发者<br>打不开xxxx，因为 Apple 无法检查其是否包含恶意软件</p><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>1.打开系统设置<br>2.点击左侧边栏的隐私与安全性<br>3.在下方找到安全性，选择允许从任何来源下载应用程序</p><img src="https://www.helloimg.com/images/2023/05/20/oEU1Vr.png" width="60%" height="90%"><p>假如你不想找的话，可以在终端中输入指令完成此操作<br>在终端中输入【sudo spctl –master-disable】</p><img src="https://s1.imagehub.cc/images/2023/05/20/18001684592389_.pic.png" width="80%" height="60%"><p>多数情况下这种方法可以解决<br>在打开新文件的时候，依旧有弹窗<br>再次打开隐私与安全，能够找到是否打开该程序的按钮，点击打开即可</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>通过终端执行命令行代码来绕过应用签名认证<br>打开终端，输入以下命令：<br>sudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;xxxxxx.app</p><p>将上面的 xxxxxx.app 换成你的App名称，比如 dev-sidecar.app</p><p>sudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;dev-sidecar.app</p><p>假如你对App路径不熟悉你可以用以下办法：</p><p>1.复制以下命令粘贴到终端</p><p>sudo xattr -rd com.apple.quarantine </p><p>2.打开访达，点击左侧的应用程序，将应用拖进终端中，此时会在终端中自动生成App路径，然后按键盘的回车键，输入密码，再按回车键，完成。</p><img src="https://s1.imagehub.cc/images/2023/05/20/18011684592766_.pic_hd.png" width="90%" height="50%"><p>注意： quarantine 与后面的&#x2F;之间必须有个空格</p>]]></content>
    
    
    <summary type="html">无法打开Mac上的软件解决方案</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>this指针</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/15/this%E6%8C%87%E9%92%88/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/15/this%E6%8C%87%E9%92%88/</id>
    <published>2023-05-15T08:23:15.000Z</published>
    <updated>2023-05-20T14:37:31.352Z</updated>
    
    <content type="html"><![CDATA[<p>成员函数调用本身时用this指针</p><img src="https://s1.imagehub.cc/images/2023/05/15/image10d895e6d4e49f3a.png" width="90%" height="40%"><p>当构造函数中的形参与数据成员重名时必须用this指针</p><img src="https://s1.imagehub.cc/images/2023/05/15/image89ba83e49e0238b7.png" width="90%" height="40%">]]></content>
    
    
    <summary type="html">this指针应用情况</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>指向基类的指针</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/15/%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/15/%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88/</id>
    <published>2023-05-15T08:21:24.000Z</published>
    <updated>2023-05-20T14:36:45.397Z</updated>
    
    <content type="html"><![CDATA[<p>指向基类的指针可以指向子类<br>animal *p;(基类)<br>monkey c;(子类)<br>p&#x3D;&amp;c;</p><p>如果子类覆盖了基类的成员，但是通过基类指针所访问的成员仍是基类的成员，而不是子类的成员</p><p>当指向子类的基类指针调用被覆盖了的成员时，假如基类中的被覆盖成员为虚函数，则调用子类中的成员，如果其不是虚函数，则调用基类中的成员。</p>]]></content>
    
    
    <summary type="html">对指向基类的指针进行解释</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基本引用</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8/</id>
    <published>2023-05-15T08:17:31.000Z</published>
    <updated>2023-05-20T14:37:05.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实际上是起别名"><a href="#实际上是起别名" class="headerlink" title="实际上是起别名"></a>实际上是起别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=1001;</span><br><span class="line">int &amp;b = a;</span><br><span class="line">b=1002</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">//输出为1002；</span><br></pre></td></tr></table></figure><h2 id="用在形参："><a href="#用在形参：" class="headerlink" title="用在形参："></a>用在形参：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void change(int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">b=1003;</span><br><span class="line">&#125;</span><br><span class="line">int a=1001;</span><br><span class="line">change(a);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">//输出为1003；</span><br></pre></td></tr></table></figure><h2 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class mm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">string&amp; getname()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mm a;</span><br><span class="line">a.getname()=&quot;Tom&quot;</span><br><span class="line">//此时a中的name 为Tom</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">三种基本引用类型</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/15/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/15/%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2023-05-15T08:12:09.000Z</published>
    <updated>2023-05-20T14:37:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的虚函数是用于实现多态性的一种机制。虚函数可以在基类中声明并在派生类中重写，当通过基类指针或引用调用虚函数时，实际调用的是派生类中的实现，这种行为被称为动态绑定。</p><h2 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h2><p>允许派生类重写基类中定义的函数。在基类中声明虚函数，如果派生类中有同名函数并且使用了关键字 virtual 进行了声明，那么这个函数就是虚函数，可以被派生类重写。<br>实现动态绑定。如果使用基类指针或引用调用虚函数，实际上调用的是指向对象的实际类型所实现的版本，而不是基类中的版本。这使得程序能够以一种更加灵活的方式使用对象，可以在运行时动态地确定调用哪个函数。<br>虚函数的应用广泛，特别是在面向对象程序设计中，常常被用来实现多态性和基于接口的编程，提高了程序的可扩展性和可维护性。<br>虚函数用于弥补覆盖的缺陷<br>对函数进行覆盖后，在基类中调用覆盖后的函数还是会调用基类中的函数，<br>但是当基类中的函数为虚函数，那么将调用子类中的覆盖后的函数</p><h2 id="虚函数的定义"><a href="#虚函数的定义" class="headerlink" title="虚函数的定义"></a>虚函数的定义</h2><p>在实现c++多态时会用到虚函数。虚函数使用的其核心目的是通过基类访问派生类定义的函数。所谓虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。一般格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> base();</span><br><span class="line"> virtual void test(); //定义的一个虚函数</span><br><span class="line">private:</span><br><span class="line"> char *basePStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码在基类中定义了一个test的虚函数，所有可以在其子类重新定义父类的做法这种行为成为覆盖（override）,或者为重写。</p><p>常见用法：声明基类指针，利用指针指向任意一个子类对象，调用相关的虚函数，动态绑定，由于编写代码时不能确定被调用的是基类函数还是那个派生类函数，所以被称为“”虚“”函数。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。</p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>定义：</p><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 &#x3D;0:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void funtion1()=0</span><br></pre></td></tr></table></figure><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p><p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()&#x3D; 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p><p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p><p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p><p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>]]></content>
    
    
    <summary type="html">虚函数详解</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/15/%E7%BB%A7%E6%89%BF/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/15/%E7%BB%A7%E6%89%BF/</id>
    <published>2023-05-15T07:54:19.000Z</published>
    <updated>2023-05-15T08:09:07.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>当我们编写一个类时，发现这个类与类外一个类的成员变量和成员方法相似，并且具有一定的包含关系时，我们编写的这两个类会有很多相似的地方。</p><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>继承机制是面向对象程序设计使代码可以复用的重要手段。它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的类称为派生类。</p><p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承使类设计层次的复用。</p><p>简单来说就是，继承就是一个类复用了另外一个类的成员函数和成员变量。就好像在这个类里编写了另外一个类的成员。</p><img src="https://www.helloimg.com/images/2023/05/15/oEb7F9.png" width="90%" height="50%"><img src="https://www.helloimg.com/images/2023/05/15/oEbDnX.png" width="90%" height="50%"><img src="https://www.helloimg.com/images/2023/05/15/oEbIzg.png" width="90%" height="30%"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基类的私有成员在派生类中不可以见，基类的其它成员在派生类中的访问方式是：继承方式和基类该成员访问限定符范围那个小，就是什么访问方式，等价于min(继承方式，基类该成员访问限定符)。范围从大到小：public &gt; protected &gt; private</p><p>基类的private成员，无论以什么继承方式继承，在派生类里是不可以访问的。但是，派生类还是继承了基类，只是在语法上限制了派生类在类里或者类外对基类私有成员的访问。</p><p>基类protected成员，通过public或者protected继承方式继承的派生类，该成员变成了派生类的protected成员，只能在类里访问，不能在类外访问。但是基类的private成员，派生类不可见，在继承中体现了两者的区别。可以看出保护成员限定符因继承才出现的。</p><p>使用关键字class定义的类的默认继承方式是private，使用关键字struct定义的类的默认继承方式是public，但是，最后显示写出继承方式。<br>在实际运用中一般使用public继承，很少用protected和private继承。因为protected和private继承下来的成员只能在派生类中使用，实用性不强。</p><h2 id="基类和派生类对象的赋值转化"><a href="#基类和派生类对象的赋值转化" class="headerlink" title="基类和派生类对象的赋值转化"></a>基类和派生类对象的赋值转化</h2><p>派生类可以给基类赋值<br>派生类对象可以赋值给基类对象&#x2F;基类指针&#x2F;基类引用。这里有一个形象的说法是切片或者切割，意思是将派生类父类中的那部分切来赋值过去。</p><img src="https://www.helloimg.com/images/2023/05/15/oEbKtP.png" width="90%" height="80%"><img src="https://www.helloimg.com/images/2023/05/15/oEbUv6.png" width="90%" height="30%"><p>基类对象不能赋值给派生类对象。因为基类对象中可能没有派生类中的成员，所以赋值不过去。<br>但是当一个基类指针指向派生类时，可以通过强制类型转化赋值给派生类指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">string _name; // 姓名</span><br><span class="line">string _sex; // 性别</span><br><span class="line">int _age; // 年龄</span><br><span class="line">&#125;;</span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int _No; // 学号</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">Student s;</span><br><span class="line">// 1.子类对象可以赋值给父类对象/指针/引用</span><br><span class="line">Person p1 = s;</span><br><span class="line">Person* pp = &amp;s;</span><br><span class="line">Person&amp; rp = s;</span><br><span class="line"> </span><br><span class="line">//2.基类对象不能赋值给派生类对象，会报错</span><br><span class="line">s = p1;</span><br><span class="line"> </span><br><span class="line">// 3.基类的指针可以通过强制类型转换赋值给派生类的指针</span><br><span class="line">    //前提，指向基类指针指向派生类</span><br><span class="line">pp = &amp;s;</span><br><span class="line">Student* ps1 = (Student*)pp; // 这种情况转换时可以的。</span><br><span class="line">ps1-&gt;_No = 10;</span><br><span class="line">//基类指针指向基类的话</span><br><span class="line">pp = &amp;p1;</span><br><span class="line">Student* ps2 = (Student*)pp; // 这种情况转换时虽然可以，但是会存在越界访问的问题，</span><br><span class="line">//由于基类中没有_NO成员，访问会越界</span><br><span class="line">ps2-&gt;_No = 10;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>在继承体系中基类和派生类具有独立的作用域。</p><p>派生类和基类具有同名成员(成员变量和成员函数)时，派生类将屏蔽对父类同名成员的直接访问，这种情况叫隐藏(重定义)。除非指定作用域：基类名 : : 基类成员 (显示访问)</p><img src="https://www.helloimg.com/images/2023/05/15/oEbgfn.png" width="90%" height="40%"><p>如果基类与派生类有同名函数，那么基类的同名函数将会被隐藏，在调用函数的时候，基类函数无法被调用，只能调用派生类的函数（传参不同也不可，函数隐藏不同于函数重载）</p><img src="https://www.helloimg.com/images/2023/05/15/oEbrqR.png" width="60%" height="60%"><img src="https://www.helloimg.com/images/2023/05/15/oEbVTz.png" width="90%" height="40%"><p>注意：在实际的继承体系同最好不要定义同名成员。</p><h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><p>派生类的构造函数必须去调用基类的构造函数去初始化基类的那一部分成员。如果基类没有默认构造函数(无参，全缺省或者编译器生成)，必须在派生类构造函数中显示调用基类的构造函数。<br>有参数的子类构造函数必须调用父类构造函数<br>&lt;子类名&gt;::&lt;子类名&gt;(参数列表):父类名(参数列表)<br>{<br>    成员&#x3D;形参<br>}</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>派生类的拷贝构造函数必须调用基类的拷贝构造函数完成属于基类成员的拷贝构造。</p><p>派生类的赋值操作符重载函数(operator&#x3D;)必须调用基类的赋值操作符重载函数(operator&#x3D;)赋值属于基类的成员。<br>注意：在派生类里调用基类的赋值重载函数要加类作用域限定符。</p><img src="https://www.helloimg.com/images/2023/05/15/oEbYUA.png" width="90%" height="40%"><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>派生类先调用基类的构造，再调用派生类的构造。<br>派生类对象析构，先调用派生类的析构，再调用基类的析构。</p><h2 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h2><p>基类友元的关系，派生类不能继承下来。也就是说基类的友元不能访问派生类的私有和保护成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Student;//声明</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">friend void Print(Person&amp; p, Student&amp; s);//友元</span><br><span class="line">protected:</span><br><span class="line">string _name = &quot;tom&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Student :public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //friend void Print(Person&amp; p, Student&amp; s);解决</span><br><span class="line">protected:</span><br><span class="line">int _age = 10;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void Print(Person&amp; p, Student&amp; s)&#123;</span><br><span class="line">cout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; s._age &lt;&lt; endl;</span><br><span class="line">//报错，友元不能继承，不能访问派生类的保护成员</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">Print(p, s);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p> 基类定义了一个静态成员，在继承体系中，只有这一个成员。也就是说，无论派生了多少派生类，操作的这个静态成员都是一个成员。</p><img src="https://www.helloimg.com/images/2023/05/15/oEbhP5.png" width="40%" height="100%"><img src="https://s1.imagehub.cc/images/2023/05/15/image.png" width="90%" height="40%">]]></content>
    
    
    <summary type="html">构造函数详解</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="https://xadmc.gitee.io/stouyx/2023/05/09/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://xadmc.gitee.io/stouyx/2023/05/09/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-05-09T08:38:33.000Z</published>
    <updated>2023-05-11T04:29:36.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要构造函数"><a href="#为什么需要构造函数" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h2><img src="https://www.helloimg.com/images/2023/05/09/oxnHQ6.png" width="60%" height="70%"><p>每次需要调用SetDate函数<br>十分麻烦<br>此时需要构造函数来出👋</p><h2 id="构造函数的概念特征"><a href="#构造函数的概念特征" class="headerlink" title="构造函数的概念特征"></a>构造函数的概念特征</h2><p>能够保证对象被初始化。<br>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间。（虽然构造函数的名字叫构造）<br>构造函数是特殊的成员函数，主要特征如下：<br>① 构造函数的函数名和类名是相同的<br>② 构造函数无返回值<br>③ 构造函数可以重载<br>③ 会在对象实例化时自动调用对象定义出来。</p><img src="https://www.helloimg.com/images/2023/05/09/oxnbyn.png" width="70%" height="80%"><img src="https://www.helloimg.com/images/2023/05/09/oxnMmR.png" width="100%" height="20%"><p>不给参数时就会调用无参构造函数，给参数则会调用带参构造函数<br>！！！！<br>注意事项：<br>① 构造函数是特殊的，不是常规的成员函数，不能直接调 </p><p>d1.Date();</p><p>② 如果通过无参构造函数创建对象，对象后面不用跟括号，否则就成了函数声明。</p><img src="https://www.helloimg.com/images/2023/05/09/oxn2cz.png" width="70%" height="80%"><p>③ 这里如果调用带参构造函数，我们需要传递三个参数（这里我们没设缺省） 。<br>④ 如果你没有自己定义构造函数（类中未显式定义），C++ 编译器会自动生成一个无参的默认构造函数。当然，如果你自己定义了，编译器就不会帮你生成了。<br><img src="https://www.helloimg.com/images/2023/05/09/oxnTVA.png" width="60%" height="80%"></p><p>输出：</p><img src="https://www.helloimg.com/images/2023/05/09/oxn9X5.png" width="80%" height="20%"><h2 id="默认构造函数："><a href="#默认构造函数：" class="headerlink" title="默认构造函数："></a>默认构造函数：</h2><p>任何一个类的默认构造函数，只有三种：<br>① 无参的构造函数<br>② 全缺省的构造函数<br>③ 我们不写，编译器自己生成的构造函数<br>并且默认构造函数只能有一个！<br>注意事项：<br>① 无参构造函数、全缺省构造函数、我们没写编译器默认生成的无参构造函数，都可以认为是默认成员函数。<br>② 语法上无参和全缺省可以同时存在，但如果同时存在会引发二义性：<br>可以同时存在，但是不能调用构造函数否则报错</p><p>无参构造函数，全缺省构造函数：</p><img src="https://www.helloimg.com/images/2023/05/09/oxnc8m.png" width="70%" height="40%"><p>举例：</p><img src="https://s1.imagehub.cc/images/2023/05/09/image.png" width="70%" height="80%"><img src="https://www.helloimg.com/images/2023/05/09/oxnsrY.png" width="70%" height="80%">]]></content>
    
    
    <summary type="html">构造函数详解</summary>
    
    
    
    <category term="语法" scheme="https://xadmc.gitee.io/stouyx/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://xadmc.gitee.io/stouyx/tags/C/"/>
    
  </entry>
  
</feed>
