<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac软件无法打开</title>
    <url>/Stouyx/2023/05/20/Mac%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<h2 id="常见的三种报错方式"><a href="#常见的三种报错方式" class="headerlink" title="常见的三种报错方式"></a>常见的三种报错方式</h2><p>xxx已损坏，无法打开，你应该将它移到废纸篓解决办法<br>打不开 xxx，因为它来自身份不明的开发者<br>打不开xxxx，因为 Apple 无法检查其是否包含恶意软件</p>
<h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>1.打开系统设置<br>2.点击左侧边栏的隐私与安全性<br>3.在下方找到安全性，选择允许从任何来源下载应用程序</p>
<img src="https://www.helloimg.com/images/2023/05/20/oEU1Vr.png" width="60%" height="90%">

<p>假如你不想找的话，可以在终端中输入指令完成此操作<br>在终端中输入【sudo spctl –master-disable】</p>
<img src="https://s1.imagehub.cc/images/2023/05/20/18001684592389_.pic.png" width="80%" height="60%">


<p>多数情况下这种方法可以解决<br>在打开新文件的时候，依旧有弹窗<br>再次打开隐私与安全，能够找到是否打开该程序的按钮，点击打开即可</p>
<h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>通过终端执行命令行代码来绕过应用签名认证<br>打开终端，输入以下命令：<br>sudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;xxxxxx.app</p>
<p>将上面的 xxxxxx.app 换成你的App名称，比如 dev-sidecar.app</p>
<p>sudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;dev-sidecar.app</p>
<p>假如你对App路径不熟悉你可以用以下办法：</p>
<p>1.复制以下命令粘贴到终端</p>
<p>sudo xattr -rd com.apple.quarantine </p>
<p>2.打开访达，点击左侧的应用程序，将应用拖进终端中，此时会在终端中自动生成App路径，然后按键盘的回车键，输入密码，再按回车键，完成。</p>
<img src="https://s1.imagehub.cc/images/2023/05/20/18011684592766_.pic_hd.png" width="90%" height="50%">


<p>注意： quarantine 与后面的&#x2F;之间必须有个空格</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>this指针</title>
    <url>/Stouyx/2023/05/15/this%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>成员函数调用本身时用this指针</p>
<img src="https://s1.imagehub.cc/images/2023/05/15/image10d895e6d4e49f3a.png" width="90%" height="40%">

<p>当构造函数中的形参与数据成员重名时必须用this指针</p>
<img src="https://s1.imagehub.cc/images/2023/05/15/image89ba83e49e0238b7.png" width="90%" height="40%">
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>停车场管理系统</title>
    <url>/Stouyx/2023/05/08/%E5%81%9C%E8%BD%A6%E5%9C%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>系统演示视频：<a href="https://b23.tv/2scBrDx">🔗</a><br>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#pragma warning( disable : 4992)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class chang</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int car_sum;</span><br><span class="line">    int electric_sum;</span><br><span class="line">    int truck_sum;</span><br><span class="line">    int car_price;</span><br><span class="line">    int electric_price;</span><br><span class="line">    int truck_price;</span><br><span class="line">    chang()</span><br><span class="line">    &#123;</span><br><span class="line">        car_sum=0;</span><br><span class="line">        electric_sum=0;</span><br><span class="line">        truck_sum=0;</span><br><span class="line">        car_price=0;</span><br><span class="line">        electric_price=0;</span><br><span class="line">        truck_price=0;</span><br><span class="line">    &#125;</span><br><span class="line">    chang(int a,int b,int c,int d,int e,int f)</span><br><span class="line">    &#123;</span><br><span class="line">        car_sum=a;</span><br><span class="line">        electric_sum=b;</span><br><span class="line">        truck_sum=c;</span><br><span class="line">        car_price=d;</span><br><span class="line">        electric_price=e;</span><br><span class="line">        truck_price=f;</span><br><span class="line">    &#125;</span><br><span class="line">    friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const chang &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp; cout, const chang &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;小轿车总数：&quot;&lt;&lt;st.car_sum&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;电动车总数：&quot;&lt;&lt;st.electric_sum&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;货车总数：&quot;&lt;&lt;st.truck_sum&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;小轿车停车价格：&quot;&lt;&lt;st.car_price&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;电动车停车价格：&quot;&lt;&lt;st.electric_price&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;货车停车价格：&quot;&lt;&lt;st.truck_price&lt;&lt;endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">class Time</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">    int hour;</span><br><span class="line">    int min;</span><br><span class="line">    Time(int _year=0, int _month=0, int _day=0, int _hour=0, int _min=0)</span><br><span class="line">    &#123;</span><br><span class="line">        year = _year;</span><br><span class="line">        month = _month;</span><br><span class="line">        day = _day;</span><br><span class="line">        hour = _hour;</span><br><span class="line">        min = _min;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; &quot;年&quot; &lt;&lt; month &lt;&lt; &quot;月&quot; &lt;&lt; day &lt;&lt; &quot;日&quot; &lt;&lt; hour &lt;&lt; &quot;时&quot; &lt;&lt; min &lt;&lt; &quot;分&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const Time &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp; cout, const Time &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; st.year &lt;&lt; &quot;年&quot; &lt;&lt; st.month &lt;&lt; &quot;月&quot; &lt;&lt; st.day &lt;&lt; &quot;日&quot; &lt;&lt; st.hour &lt;&lt; &quot;时&quot; &lt;&lt; st.min &lt;&lt; &quot;分&quot; &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">class park</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Time t;</span><br><span class="line">    int type;</span><br><span class="line">    int chewei;//车位号</span><br><span class="line">    char chepai[5];//车牌号</span><br><span class="line">    bool condition;</span><br><span class="line">    park(Time _t,int _type,int a,char* c, bool b)</span><br><span class="line">    &#123;</span><br><span class="line">        t=_t;</span><br><span class="line">        type = _type;</span><br><span class="line">        chewei = a;</span><br><span class="line">        condition = false;</span><br><span class="line">        strcpy(chepai, c);</span><br><span class="line">    &#125;</span><br><span class="line">    park()</span><br><span class="line">    &#123;</span><br><span class="line">        chepai[0]=&#x27;\0&#x27;;</span><br><span class="line">        type=0;</span><br><span class="line">        chewei=0;</span><br><span class="line">        condition = false;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        if(type==1)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;轿车&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(type==2)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;电动车&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(type==3)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;货车&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;车位号：&quot;&lt;&lt;chewei&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;车牌号：&quot;&lt;&lt;chepai&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class vehicle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Time t;</span><br><span class="line">    char* car_num;</span><br><span class="line">    bool condition;</span><br><span class="line">    int chewei;</span><br><span class="line">    virtual void in() = 0;</span><br><span class="line">    virtual void out() = 0;</span><br><span class="line">    virtual void print() = 0;</span><br><span class="line">    vehicle(Time _t,char* a,int b ,bool c)</span><br><span class="line">    &#123;</span><br><span class="line">        t = _t;</span><br><span class="line">        strcpy(car_num, a);</span><br><span class="line">        chewei=b;</span><br><span class="line">        condition = c;</span><br><span class="line">    &#125;</span><br><span class="line">    vehicle()</span><br><span class="line">    &#123;</span><br><span class="line">        car_num=0;</span><br><span class="line">        chewei=0;</span><br><span class="line">        condition=false;</span><br><span class="line">    &#125;</span><br><span class="line">    ~vehicle()</span><br><span class="line">    &#123;</span><br><span class="line">        delete []car_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class electric : public vehicle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    electric(Time _t, char* a,int b, bool d):vehicle(_t,a,b,d)&#123;&#125;</span><br><span class="line">    electric():vehicle()&#123;&#125;</span><br><span class="line">    virtual void in();</span><br><span class="line">    virtual void out();</span><br><span class="line">    virtual void print();</span><br><span class="line">&#125;;</span><br><span class="line">void electric::in()</span><br><span class="line">&#123;</span><br><span class="line">    condition = true;</span><br><span class="line">&#125;</span><br><span class="line">void electric::out()</span><br><span class="line">&#123;</span><br><span class="line">    condition = false;</span><br><span class="line">&#125;</span><br><span class="line">void electric::print()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;      电动车&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;车牌号：&quot; &lt;&lt; car_num&lt;&lt;endl;</span><br><span class="line">    if (condition == true) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;是&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;进入停车场的时间:&quot; &lt;&lt; endl;</span><br><span class="line">        t.print();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;否&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class car : public vehicle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void in();</span><br><span class="line">    virtual void out();</span><br><span class="line">    virtual void print();</span><br><span class="line">    car(Time _t, char* a,int b, bool d):vehicle(_t,a,b,d) &#123;&#125;</span><br><span class="line">    car():vehicle()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void car::in()</span><br><span class="line">&#123;</span><br><span class="line">    condition = true;</span><br><span class="line">&#125;</span><br><span class="line">void car::out()</span><br><span class="line">&#123;</span><br><span class="line">    condition = false;</span><br><span class="line">&#125;</span><br><span class="line">void car::print()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;      小轿车&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;车牌号：&quot; &lt;&lt; car_num &lt;&lt; endl;</span><br><span class="line">    if (condition == true) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;是&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;进入停车场的时间:&quot; &lt;&lt; endl;</span><br><span class="line">        t.print();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;否&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class truck : public vehicle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int load;</span><br><span class="line">    virtual void in();</span><br><span class="line">    virtual void out();</span><br><span class="line">    virtual void print();</span><br><span class="line">    truck(Time _t,char* a, int b,int c, bool d);</span><br><span class="line">    truck():vehicle()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">truck::truck(Time _t, char* a, int b,int c, bool d) : vehicle(_t,a,b, d)</span><br><span class="line">&#123;</span><br><span class="line">    load = c;</span><br><span class="line">&#125;</span><br><span class="line">void truck::in()</span><br><span class="line">&#123;</span><br><span class="line">    condition = true;</span><br><span class="line">&#125;</span><br><span class="line">void truck::out()</span><br><span class="line">&#123;</span><br><span class="line">    condition = false;</span><br><span class="line">&#125;</span><br><span class="line">void truck::print()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;      货车&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;车牌号：&quot; &lt;&lt; car_num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;载货量：&quot; &lt;&lt; load &lt;&lt; endl;</span><br><span class="line">    if (condition == true) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;是&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;进入停车场的时间:&quot; &lt;&lt; endl;</span><br><span class="line">        t.print();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;是否停在停车场：&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;否&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool leap_year(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if ((a % 4 == 0 &amp;&amp; a % 100 != 0 )|| a % 400 == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int sum_time(Time a,Time b)//后面是取车前面是停车</span><br><span class="line">&#123;</span><br><span class="line">    int leap_year_num = 0;</span><br><span class="line">    int normal_year_num = 0;</span><br><span class="line">    int day_left=0;</span><br><span class="line">    int day_right = 0;</span><br><span class="line">    int hour_left = 0;</span><br><span class="line">    int hour_right = 0;</span><br><span class="line">    for (int i = a.year+1; i &lt;= b.year; i++) &#123;</span><br><span class="line">        if (leap_year(i)) &#123;</span><br><span class="line">            leap_year_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            normal_year_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (leap_year(a.year)) &#123;</span><br><span class="line">        if (a.month == 1) &#123;</span><br><span class="line">            day_left = 366 - a.day-1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 2) &#123;</span><br><span class="line">            day_left = 306 + (29 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 3) &#123;</span><br><span class="line">            day_left = 275 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 4) &#123;</span><br><span class="line">            day_left = 245 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 5) &#123;</span><br><span class="line">            day_left = 214 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 6) &#123;</span><br><span class="line">            day_left = 184 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 7) &#123;</span><br><span class="line">            day_left = 153 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 8) &#123;</span><br><span class="line">            day_left = 122 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 9) &#123;</span><br><span class="line">            day_left = 92 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 10) &#123;</span><br><span class="line">            day_left = 61 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 11) &#123;</span><br><span class="line">            day_left = 31 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 12) &#123;</span><br><span class="line">            day_left = 0 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (a.month == 1) &#123;</span><br><span class="line">            day_left = 365 - a.day - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 2) &#123;</span><br><span class="line">            day_left = 306 + (28 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 3) &#123;</span><br><span class="line">            day_left = 275 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 4) &#123;</span><br><span class="line">            day_left = 245 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 5) &#123;</span><br><span class="line">            day_left = 214 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 6) &#123;</span><br><span class="line">            day_left = 184 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 7) &#123;</span><br><span class="line">            day_left = 153 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 8) &#123;</span><br><span class="line">            day_left = 122 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 9) &#123;</span><br><span class="line">            day_left = 92 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 10) &#123;</span><br><span class="line">            day_left = 61 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 11) &#123;</span><br><span class="line">            day_left = 31 + (30 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 12) &#123;</span><br><span class="line">            day_left = 0 + (31 - a.day - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (leap_year(b.year)) &#123;</span><br><span class="line">        if (a.month == 1) &#123;</span><br><span class="line">            day_right = b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 2) &#123;</span><br><span class="line">            day_right = 31+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 3) &#123;</span><br><span class="line">            day_right = 60+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 4) &#123;</span><br><span class="line">            day_right = 91+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 5) &#123;</span><br><span class="line">            day_right = 121+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 6) &#123;</span><br><span class="line">            day_right = 152+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 7) &#123;</span><br><span class="line">            day_right = 182+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 8) &#123;</span><br><span class="line">            day_right = 213+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 9) &#123;</span><br><span class="line">            day_right = 244+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 10) &#123;</span><br><span class="line">            day_right = 274+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 11) &#123;</span><br><span class="line">            day_right = 305+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 12) &#123;</span><br><span class="line">            day_right = 335+b.day;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (a.month == 1) &#123;</span><br><span class="line">            day_right = b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 2) &#123;</span><br><span class="line">            day_right = 31 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 3) &#123;</span><br><span class="line">            day_right = 59 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 4) &#123;</span><br><span class="line">            day_right = 90 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 5) &#123;</span><br><span class="line">            day_right = 120 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 6) &#123;</span><br><span class="line">            day_right = 151 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 7) &#123;</span><br><span class="line">            day_right = 181 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 8) &#123;</span><br><span class="line">            day_right = 212 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 9) &#123;</span><br><span class="line">            day_right = 243 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 10) &#123;</span><br><span class="line">            day_right = 273 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 11) &#123;</span><br><span class="line">            day_right = 304 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.month == 12) &#123;</span><br><span class="line">            day_right = 334 + b.day;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hour_left = 24 - a.hour - 1;</span><br><span class="line">    hour_right = b.hour;</span><br><span class="line">    if (a.year == b.year &amp;&amp; a.month == b.month &amp;&amp; a.day == b.day) &#123;</span><br><span class="line">        if (b.min &gt; a.min) &#123;</span><br><span class="line">            return (b.hour - a.hour + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return (b.hour - a.hour);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return(8760 * normal_year_num + 8784 * leap_year_num + 24 * day_left + 24 * day_right + hour_left + hour_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool judge_chepai(char* a,char* b)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long num_a;</span><br><span class="line">    unsigned long num_b;</span><br><span class="line">    num_a=strlen(a);</span><br><span class="line">    num_b=strlen(b);</span><br><span class="line">    if(num_a!=num_b)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int flag=0;</span><br><span class="line">        for(int i=0;i&lt;num_a;i++)&#123;</span><br><span class="line">            if(a[i]!=b[i])&#123;</span><br><span class="line">                flag=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int vehicle_kind(char* pai,park* Car,park* Electric ,park* Truck,int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    int type=0;</span><br><span class="line">    for(int i=0;i&lt;=a;i++)&#123;</span><br><span class="line">        if(judge_chepai(Car[i].chepai,pai))&#123;</span><br><span class="line">            type=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;=b;i++)&#123;</span><br><span class="line">        if(Electric[i].chepai==pai)&#123;</span><br><span class="line">            type=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;=c;i++)&#123;</span><br><span class="line">        if(Truck[i].chepai==pai)&#123;</span><br><span class="line">            type=3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return type;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;    停车场管理系统&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (1)初始化停车场&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (2)停车&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (3)取车&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (4)查询车辆&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (5)显示停车场信息&quot; &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (6)系统使用说明&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (7)清除数据&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;  (8)退出&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;第一次使用系统请先初始化停车场&quot; &lt;&lt; endl;</span><br><span class="line">    int flag;</span><br><span class="line">    int car_sum=0;</span><br><span class="line">    int electric_sum=0;</span><br><span class="line">    int truck_sum=0;</span><br><span class="line">    int TYPE=0;</span><br><span class="line">    int choose_wei=0;</span><br><span class="line">    char* pai;</span><br><span class="line">    pai=new char[5];</span><br><span class="line">    park* tcc = NULL;</span><br><span class="line">    int wei=0;</span><br><span class="line">    int Load;</span><br><span class="line">    int car_price=0;</span><br><span class="line">    int electric_price=0;</span><br><span class="line">    int truck_price=0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;请输入您需要的操作类型：&quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; flag;</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            fstream read;</span><br><span class="line">            fstream write;</span><br><span class="line">            read.open(&quot;chang.dat&quot;,ios::in|ios::binary);</span><br><span class="line">            chang c;</span><br><span class="line">            read.read((char*)&amp;c, sizeof(c));</span><br><span class="line">            if(c.car_sum==0)&#123;</span><br><span class="line">                write.open(&quot;chang.dat&quot;,ios::out|ios::binary);</span><br><span class="line">                cout&lt;&lt;&quot;无存档&quot;&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; &quot;请依次输入您停车场轿车，电动车，货车的容量&quot; &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; &quot;轿车：&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; car_sum;</span><br><span class="line">                cout &lt;&lt; &quot;电动车：&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; electric_sum;</span><br><span class="line">                cout &lt;&lt; &quot;货车：&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; truck_sum;</span><br><span class="line">                cout &lt;&lt; &quot;您的停车场已经根据轿车，电动车，货车数量编辑好车位号&quot; &lt;&lt; endl;</span><br><span class="line">                //park.type=1轿车2电动车3货车</span><br><span class="line">                cout&lt;&lt;&quot;请输入您的收费标准(元/小时)&quot;&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; &quot;轿车&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; car_price;</span><br><span class="line">                cout &lt;&lt; &quot;电动车&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; electric_price;</span><br><span class="line">                cout &lt;&lt; &quot;货车&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; truck_price;</span><br><span class="line">                cout &lt;&lt; &quot;停车场已初始化完成&quot; &lt;&lt; endl;</span><br><span class="line">                chang n;</span><br><span class="line">                n.car_sum=car_sum;</span><br><span class="line">                n.electric_sum=electric_sum;</span><br><span class="line">                n.truck_sum=truck_sum;</span><br><span class="line">                n.car_price=car_price;</span><br><span class="line">                n.electric_price=electric_price;</span><br><span class="line">                n.truck_price=truck_price;</span><br><span class="line">                write.write((char*)&amp;n, sizeof(n));</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int flag=0;</span><br><span class="line">                cout&lt;&lt;&quot;已有存档，是否使用存档：&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;(1)使用存档&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;(2)不使用存档&quot;&lt;&lt;endl;</span><br><span class="line">                cin&gt;&gt;flag;</span><br><span class="line">                chang n;</span><br><span class="line">                read.read((char*)&amp;n, sizeof(n));</span><br><span class="line">                if(flag==1)&#123;</span><br><span class="line">                    car_sum=n.car_sum;</span><br><span class="line">                    electric_sum=n.electric_sum;</span><br><span class="line">                    truck_sum=n.truck_sum;</span><br><span class="line">                    car_price=n.car_price;</span><br><span class="line">                    electric_price=n.electric_price;</span><br><span class="line">                    truck_price=n.truck_price;</span><br><span class="line">                    cout &lt;&lt; &quot;停车场已初始化完成&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag==2)&#123;</span><br><span class="line">                    cout &lt;&lt; &quot;请依次输入您停车场轿车，电动车，货车的容量&quot; &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; &quot;轿车：&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; car_sum;</span><br><span class="line">                    cout &lt;&lt; &quot;电动车：&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; electric_sum;</span><br><span class="line">                    cout &lt;&lt; &quot;货车：&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; truck_sum;</span><br><span class="line">                    cout &lt;&lt; &quot;您的停车场已经根据轿车，电动车，货车数量编辑好车位号&quot; &lt;&lt; endl;</span><br><span class="line">                    //park.type=1轿车2电动车3货车</span><br><span class="line">                    cout&lt;&lt;&quot;请输入您的收费标准(元/小时)&quot;&lt;&lt;endl;</span><br><span class="line">                    cout &lt;&lt; &quot;轿车&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; car_price;</span><br><span class="line">                    cout &lt;&lt; &quot;电动车&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; electric_price;</span><br><span class="line">                    cout &lt;&lt; &quot;货车&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; truck_price;</span><br><span class="line">                    cout &lt;&lt; &quot;停车场已初始化完成&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tcc=new class park[car_sum+electric_sum+truck_sum];</span><br><span class="line">            for (int i = 0; i &lt; car_sum; i++) &#123;</span><br><span class="line">                tcc[i].type = 1;</span><br><span class="line">                tcc[i].chewei = i;</span><br><span class="line">                tcc[i].chepai[0] = &#x27;\0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = car_sum; i &lt; car_sum+electric_sum; i++) &#123;</span><br><span class="line">                tcc[i].type = 2;</span><br><span class="line">                tcc[i].chewei = i-car_sum+1;</span><br><span class="line">                tcc[i].chepai[0] = &#x27;\0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = car_sum+electric_sum; i &lt;car_sum+electric_sum+truck_sum; i++) &#123;</span><br><span class="line">                tcc[i].type = 3;</span><br><span class="line">                tcc[i].chewei = i-car_sum-electric_sum+1;</span><br><span class="line">                tcc[i].chepai[0] = &#x27;\0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            chang m(car_sum,electric_sum,truck_sum,car_price,electric_price,truck_price);</span><br><span class="line">            write.write((char*)&amp;m, sizeof(m));</span><br><span class="line">            write.close();</span><br><span class="line">            read.close();</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==8)&#123;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==6)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;1.初始化停车场：分别输入轿车电动车货车的数量，为其依次分配停车场位置，并编号，分别设置停不同车的停车场停车的价格。2.停车：输入想要停的车的类型，并输入想要停入的车位号，如果该车位有车则会提示该车位有车，如果该车位无车，则可以停入，并把该车的信息录入文件。3.取车：根据车牌号检索汽车的位置，能够自动读取系统时间与进入停车场的时间，自动进行计算，显示停车时长，删除该车的信息，显示停车过程的价格。4.查询：分为两种查询途径，第一种为按车牌号查找，第二种为按车位号查找，分别取出停车场信息，然后遍历查找，显示其详细信息。5.显示停车场信息：显示当前停车场的各种车辆车位数与停车数。6.帮助：显示该系统的使用帮助。7.清除数据：分为两种操作，第一种为重置该停车场的基础信息，第二种为清除所有停车场中的车辆信息。8.退出：退出该系统。&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(car_sum==0)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;未完成初始化，请先对停车场进行初始化&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if (flag == 2) &#123;</span><br><span class="line">                fstream write;</span><br><span class="line">                write.open(&quot;park.dat&quot;, ios::app | ios::binary);</span><br><span class="line">                if (!write) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl;</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">                time_t nowtime;</span><br><span class="line">                struct tm* p;</span><br><span class="line">                time(&amp;nowtime);</span><br><span class="line">                p = localtime(&amp;nowtime);</span><br><span class="line">                cout &lt;&lt; &quot;请输入您车的类型&quot; &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; &quot;(1)轿车(2)电动车(3)货车&quot; &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; TYPE;</span><br><span class="line">                Time a(p-&gt;tm_year+1900,p-&gt;tm_mon+1,p-&gt;tm_mday,p-&gt;tm_hour,p-&gt;tm_min);</span><br><span class="line">                if (TYPE == 1) &#123;</span><br><span class="line">                    int h = 0;</span><br><span class="line">                    cout&lt;&lt;&quot;轿车的停车价格为：&quot;&lt;&lt;car_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">                    while (h == 0) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;请在0-&quot; &lt;&lt; car_sum &lt;&lt; &quot;之间选择您的车位号&quot; &lt;&lt; endl;</span><br><span class="line">                        cin &gt;&gt; choose_wei;</span><br><span class="line">                        if (tcc[choose_wei-1].chepai[0]==&#x27;\0&#x27;) &#123;</span><br><span class="line">                            h = 1;</span><br><span class="line">                            cout &lt;&lt; &quot;请输入您的车牌号(4位数字)：&quot; &lt;&lt; endl;</span><br><span class="line">                            string p;</span><br><span class="line">                            cin &gt;&gt; p;</span><br><span class="line">                            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                                pai[i]=p[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            strcpy(tcc[choose_wei-1].chepai , pai);</span><br><span class="line">                            cout &lt;&lt; &quot;停车时间：&quot; &lt;&lt; endl;</span><br><span class="line">                            a.print();</span><br><span class="line">                            park m(a,1,choose_wei,pai,true);</span><br><span class="line">                            write.write((char*)&amp;m, sizeof(m));</span><br><span class="line">                            write.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            cout &lt;&lt; &quot;此车位已有车，请选择另一个车位&quot; &lt;&lt; endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (TYPE == 2) &#123;</span><br><span class="line">                    int h = 0;</span><br><span class="line">                    cout&lt;&lt;&quot;电动车的停车价格为：&quot;&lt;&lt;electric_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">                    while (h == 0) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;请在0-&quot; &lt;&lt; electric_sum &lt;&lt; &quot;之间选择您的车位号&quot; &lt;&lt; endl;</span><br><span class="line">                        cin &gt;&gt; choose_wei;</span><br><span class="line">                        if (tcc[car_sum+choose_wei-1].chepai[0] == &#x27;\0&#x27;) &#123;</span><br><span class="line">                            h = 1;</span><br><span class="line">                            cout &lt;&lt; &quot;请输入您的车牌号(4位数字)：&quot; &lt;&lt; endl;</span><br><span class="line">                            string p;</span><br><span class="line">                            cin &gt;&gt; p;</span><br><span class="line">                            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                                pai[i]=p[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            strcpy(tcc[car_sum+choose_wei-1].chepai , pai);</span><br><span class="line">                            cout &lt;&lt; &quot;停车时间：&quot; &lt;&lt; endl;</span><br><span class="line">                            a.print();</span><br><span class="line">                            park m(a,2,choose_wei,pai,true);</span><br><span class="line">                            write.write((char*)&amp;m, sizeof(m));</span><br><span class="line">                            write.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            cout &lt;&lt; &quot;此车位已有车，请选择另一个车位&quot; &lt;&lt; endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (TYPE == 3) &#123;</span><br><span class="line">                    int h = 0;</span><br><span class="line">                    cout&lt;&lt;&quot;货车的停车价格为：&quot;&lt;&lt;truck_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">                    cout &lt;&lt; &quot;请在0-&quot; &lt;&lt; truck_sum &lt;&lt; &quot;之间选择您的车位号&quot; &lt;&lt; endl;</span><br><span class="line">                    cin &gt;&gt; choose_wei;</span><br><span class="line">                    while(h==0)&#123;</span><br><span class="line">                        if (tcc[choose_wei+car_sum+electric_sum-1].chepai[0] == &#x27;\0&#x27;) &#123;</span><br><span class="line">                            h = 1;</span><br><span class="line">                            cout &lt;&lt; &quot;请输入您的车牌号(4位数字)：&quot; &lt;&lt; endl;</span><br><span class="line">                            string p;</span><br><span class="line">                            cin &gt;&gt; p;</span><br><span class="line">                            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                                pai[i]=p[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            cout &lt;&lt; &quot;请输入您的载货量(吨)：&quot; &lt;&lt; endl;</span><br><span class="line">                            cin &gt;&gt; Load;</span><br><span class="line">                            strcpy(tcc[car_sum+electric_sum+choose_wei-1].chepai,pai);</span><br><span class="line">                            cout &lt;&lt; &quot;停车时间：&quot; &lt;&lt; endl;</span><br><span class="line">                            a.print();</span><br><span class="line">                            park m(a,3,choose_wei,pai,true);</span><br><span class="line">                            write.write((char*)&amp;m, sizeof(m));</span><br><span class="line">                            write.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            cout &lt;&lt; &quot;此车位已有车，请选择另一个车位&quot; &lt;&lt; endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag == 3) &#123;</span><br><span class="line">                Time r;</span><br><span class="line">                cout &lt;&lt; &quot;请输入您要取车的车牌号(4位数字):&quot; &lt;&lt; endl;</span><br><span class="line">                string o;</span><br><span class="line">                cin &gt;&gt; o;</span><br><span class="line">                for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                    pai[i]=o[i];</span><br><span class="line">                &#125;</span><br><span class="line">                time_t nowtime;</span><br><span class="line">                struct tm* p;</span><br><span class="line">                time(&amp;nowtime);</span><br><span class="line">                p = localtime(&amp;nowtime);</span><br><span class="line">                Time a(p-&gt;tm_year+1900,p-&gt;tm_mon+1,p-&gt;tm_mday,p-&gt;tm_hour,p-&gt;tm_min);</span><br><span class="line">                fstream write;</span><br><span class="line">                fstream read;</span><br><span class="line">                read.open(&quot;park.dat&quot;,ios::in|ios::binary);</span><br><span class="line">                if(!read) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt;endl;</span><br><span class="line">                    read.close();</span><br><span class="line">                &#125;</span><br><span class="line">                park *park;</span><br><span class="line">                park= new class park [car_sum+electric_sum+truck_sum];</span><br><span class="line">                </span><br><span class="line">                int i=0;</span><br><span class="line">                while(read.read((char*)&amp;park[i],sizeof(park[i])))&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                read.close();</span><br><span class="line">                int j;</span><br><span class="line">                int hour=0;</span><br><span class="line">                int u=1;</span><br><span class="line">                for(j=0;j&lt;i;j++)&#123;</span><br><span class="line">                    if(judge_chepai(pai,park[j].chepai))&#123;</span><br><span class="line">                        u=0;</span><br><span class="line">                        r=park[j].t;</span><br><span class="line">                        hour=sum_time(park[j].t, a);</span><br><span class="line">                        for(int f=j;f&lt;i;f++)&#123;</span><br><span class="line">                            park[f]=park[f+1];</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(u==1)&#123;</span><br><span class="line">                    cout&lt;&lt;&quot;该停车场无该车&quot;&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    int n=0;</span><br><span class="line">                    write.open(&quot;park.dat&quot;,ios::out|ios::binary);</span><br><span class="line">                    while(write.write((char*)&amp;park[n],sizeof(park[n]))&amp;&amp;n&lt;i-2)&#123;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout&lt;&lt;&quot;车牌号为&quot;&lt;&lt;pai&lt;&lt;&quot;的车&quot;&lt;&lt;endl;</span><br><span class="line">                    cout&lt;&lt;&quot;停车时间为：&quot;&lt;&lt;endl;</span><br><span class="line">                    r.print();</span><br><span class="line">                    cout&lt;&lt;&quot;取车时间为：&quot;&lt;&lt;endl;</span><br><span class="line">                    a.print();</span><br><span class="line">                    cout&lt;&lt;&quot;共停车&quot;&lt;&lt;hour&lt;&lt;&quot;小时&quot;&lt;&lt;endl;</span><br><span class="line">                    if(park[j].type==1)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;需缴费&quot;&lt;&lt;hour*car_price&lt;&lt;&quot;元&quot;&lt;&lt;endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(park[j].type==2)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;需缴费&quot;&lt;&lt;hour*electric_price&lt;&lt;&quot;元&quot;&lt;&lt;endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(park[j].type==3)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;需缴费&quot;&lt;&lt;hour*truck_price&lt;&lt;&quot;元&quot;&lt;&lt;endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                write.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag==4)&#123;</span><br><span class="line">                int s=0;</span><br><span class="line">                cout&lt;&lt;&quot;(1)按车牌号查找&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;(2)按车位号查找&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;请输入查找方式：&quot;&lt;&lt;endl;</span><br><span class="line">                cin&gt;&gt;s;</span><br><span class="line">                if(s==1)&#123;</span><br><span class="line">                    cout&lt;&lt;&quot;请输入您的车牌号：&quot;&lt;&lt;endl;</span><br><span class="line">                    string p;</span><br><span class="line">                    cin &gt;&gt; p;</span><br><span class="line">                    for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                        pai[i]=p[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    fstream read;</span><br><span class="line">                    read.open(&quot;park.dat&quot;,ios::in|ios::binary);</span><br><span class="line">                    if(!read) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;error&quot; &lt;&lt;endl;</span><br><span class="line">                        read.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    park *sum;</span><br><span class="line">                    sum= new park [car_sum+electric_sum+truck_sum];</span><br><span class="line">                    </span><br><span class="line">                    int i=0;</span><br><span class="line">                    while(read.read((char*)&amp;sum[i],sizeof(sum[i])))&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    read.close();</span><br><span class="line">                    int j;</span><br><span class="line">                    int u=1;</span><br><span class="line">                    for(j=0;j&lt;i;j++)&#123;</span><br><span class="line">                        if(judge_chepai(pai,sum[j].chepai))&#123;</span><br><span class="line">                            u=0;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(u==1)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;该停车场无该车&quot;&lt;&lt;endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        Time a;</span><br><span class="line">                        sum[j].print();</span><br><span class="line">                        cout&lt;&lt;&quot;停车时间：&quot;&lt;&lt;endl;</span><br><span class="line">                        a=sum[j].t;</span><br><span class="line">                        a.print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(s==2)&#123;</span><br><span class="line">                    int type;</span><br><span class="line">                    cout&lt;&lt;&quot;(1)轿车&quot;&lt;&lt;endl;</span><br><span class="line">                    cout&lt;&lt;&quot;(2)电动车&quot;&lt;&lt;endl;</span><br><span class="line">                    cout&lt;&lt;&quot;(3)卡车&quot;&lt;&lt;endl;</span><br><span class="line">                    cout&lt;&lt;&quot;请输入车的类型：&quot;&lt;&lt;endl;</span><br><span class="line">                    cin&gt;&gt;type;</span><br><span class="line">                    cout&lt;&lt;&quot;请输入您的车位号：&quot;&lt;&lt;endl;</span><br><span class="line">                    cin&gt;&gt;wei;</span><br><span class="line">                    fstream read;</span><br><span class="line">                    read.open(&quot;park.dat&quot;,ios::in|ios::binary);</span><br><span class="line">                    if(!read) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;error&quot; &lt;&lt;endl;</span><br><span class="line">                        read.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    park *sum;</span><br><span class="line">                    sum= new park [car_sum+electric_sum+truck_sum];</span><br><span class="line">                    </span><br><span class="line">                    int i=0;</span><br><span class="line">                    while(read.read((char*)&amp;sum[i],sizeof(sum[i])))&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    read.close();</span><br><span class="line">                    int j;</span><br><span class="line">                    int u=1;</span><br><span class="line">                    for(j=0;j&lt;i;j++)&#123;</span><br><span class="line">                        if(wei==sum[j].chewei)&#123;</span><br><span class="line">                            u=0;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(u==1)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;该停车场无该车&quot;&lt;&lt;endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        Time a;</span><br><span class="line">                        sum[j].print();</span><br><span class="line">                        cout&lt;&lt;&quot;停车时间：&quot;&lt;&lt;endl;</span><br><span class="line">                        a=sum[j].t;</span><br><span class="line">                        a.print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag==5)&#123;</span><br><span class="line">                int i=0;</span><br><span class="line">                fstream read;</span><br><span class="line">                park o[car_sum+electric_sum+truck_sum];</span><br><span class="line">                read.open(&quot;park.dat&quot;,ios::in|ios::binary);</span><br><span class="line">                while(!read.eof())</span><br><span class="line">                &#123;</span><br><span class="line">                    read.read((char*)&amp;o[i],sizeof(o[i]));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                int car_num=0;</span><br><span class="line">                int electric_num=0;</span><br><span class="line">                int truck_num=0;</span><br><span class="line">                for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                    if(o[j].type==1)&#123;</span><br><span class="line">                        car_num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(o[j].type==2)&#123;</span><br><span class="line">                        electric_num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(o[j].type==3)&#123;</span><br><span class="line">                        truck_num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;&quot;轿车&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;车位总数：&quot;&lt;&lt;car_sum&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;空余车位数量：&quot;&lt;&lt;car_sum-car_num&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;价格：&quot;&lt;&lt;car_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;电动车&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;车位数：&quot;&lt;&lt;electric_sum&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;空余车位数量：&quot;&lt;&lt;electric_sum-electric_num&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;价格：&quot;&lt;&lt;electric_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;货车&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;车位数：&quot;&lt;&lt;truck_sum&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;空余车位数量：&quot;&lt;&lt;truck_sum-truck_num&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;价格：&quot;&lt;&lt;truck_price&lt;&lt;&quot;元/小时&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag==7)&#123;</span><br><span class="line">                int t;</span><br><span class="line">                cout&lt;&lt;&quot;(1)重置停车场&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;(2)重置车辆信息&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;&quot;请输入您想进行的操作：&quot;&lt;&lt;endl;</span><br><span class="line">                cin&gt;&gt;t;</span><br><span class="line">                if(t==1)&#123;</span><br><span class="line">                    fstream a;</span><br><span class="line">                    fstream b;</span><br><span class="line">                    a.open(&quot;park.dat&quot;,ios::out);</span><br><span class="line">                    b.open(&quot;chang.dat&quot;,ios::out);</span><br><span class="line">                    if(!a)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</span><br><span class="line">                        exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(!b)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</span><br><span class="line">                        exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    b.close();</span><br><span class="line">                    a.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(t==2)&#123;</span><br><span class="line">                    fstream a;</span><br><span class="line">                    a.open(&quot;park.dat&quot;,ios::out);</span><br><span class="line">                    if(!a)&#123;</span><br><span class="line">                        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</span><br><span class="line">                        exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    a.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/Stouyx/2023/05/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[n];</span><br><span class="line">int i,j,min,t;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">    min=i;</span><br><span class="line">    for(j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">        if(a[j]&lt;a[min])&#123;</span><br><span class="line">            min=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(min!=i)&#123;</span><br><span class="line">        t=a[min];</span><br><span class="line">        a[min]=a[i];</span><br><span class="line">        a[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int a[n];</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int i,j,t;</span><br><span class="line">    for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">    //n个数要比较n-1次</span><br><span class="line">        for(j=0;j&lt;n-i-1;j++)&#123;</span><br><span class="line">        //控制排序次数，已经排序好的不再参与排序</span><br><span class="line">            if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">                t=a[j];</span><br><span class="line">                a[j]=a[j+1];</span><br><span class="line">                a[j+1]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：<br>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p>
<p>以一个数组作为示例，取区间第一个数为基准数。</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th>3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><u>72</u></td>
<td align="left">6</td>
<td align="left">57</td>
<td>88</td>
<td align="left">60</td>
<td align="left">42</td>
<td align="left">83</td>
<td align="left">73</td>
<td align="left">48</td>
<td align="left">85</td>
</tr>
</tbody></table>
<p>初始时，i &#x3D; 0;  j &#x3D; 9;   X &#x3D; a[i] &#x3D; 72<br>由于已经将 a[0] 中的数保存到 X 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。<br>从j开始向前找一个比X小或等于X的数。当j&#x3D;8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]&#x3D;a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i&#x3D;3，符合条件，将a[3]挖出再填到上一个坑中a[8]&#x3D;a[3]; j–;</p>
<p>数组变为：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th>3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><u>48</u></td>
<td align="left">6</td>
<td align="left">57</td>
<td><u>88</u></td>
<td align="left">60</td>
<td align="left">42</td>
<td align="left">83</td>
<td align="left">73</td>
<td align="left"><u>88</u></td>
<td align="left">85</td>
</tr>
</tbody></table>
<p>i &#x3D; 3;   j &#x3D; 7;   X&#x3D;72<br>再重复上面的步骤，先从后向前找，再从前向后找。<br>从j开始向前找，当j&#x3D;5，符合条件，将a[5]挖出填到上一个坑中，a[3] &#x3D; a[5]; i++;<br>从i开始向后找，当i&#x3D;5时，由于i&#x3D;&#x3D;j退出。<br>此时，i &#x3D; j &#x3D; 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。<br>数组变为：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th>3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><u>48</u></td>
<td align="left">6</td>
<td align="left">57</td>
<td><u>42</u></td>
<td align="left">60</td>
<td align="left"><u>72</u></td>
<td align="left">83</td>
<td align="left">73</td>
<td align="left"><u>88</u></td>
<td align="left">85</td>
</tr>
</tbody></table>
<p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void quick_sort(int s[], int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = left, j = right, key = s[left];</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">                j--;  </span><br><span class="line">            if(i &lt; j)&#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">                i++;  </span><br><span class="line">            if(i &lt; j)&#123;</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = key;</span><br><span class="line">        quick_sort(s, left, i - 1); // 递归调用 </span><br><span class="line">        quick_sort(s, i + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>指向基类的指针</title>
    <url>/Stouyx/2023/05/15/%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>指向基类的指针可以指向子类<br>animal *p;(基类)<br>monkey c;(子类)<br>p&#x3D;&amp;c;</p>
<p>如果子类覆盖了基类的成员，但是通过基类指针所访问的成员仍是基类的成员，而不是子类的成员</p>
<p>当指向子类的基类指针调用被覆盖了的成员时，假如基类中的被覆盖成员为虚函数，则调用子类中的成员，如果其不是虚函数，则调用基类中的成员。</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/Stouyx/2023/05/09/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="为什么需要构造函数"><a href="#为什么需要构造函数" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h2><img src="https://www.helloimg.com/images/2023/05/09/oxnHQ6.png" width="60%" height="70%">

<p>每次需要调用SetDate函数<br>十分麻烦<br>此时需要构造函数来出👋</p>
<h2 id="构造函数的概念特征"><a href="#构造函数的概念特征" class="headerlink" title="构造函数的概念特征"></a>构造函数的概念特征</h2><p>能够保证对象被初始化。<br>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间。（虽然构造函数的名字叫构造）<br>构造函数是特殊的成员函数，主要特征如下：<br>① 构造函数的函数名和类名是相同的<br>② 构造函数无返回值<br>③ 构造函数可以重载<br>③ 会在对象实例化时自动调用对象定义出来。</p>
<img src="https://www.helloimg.com/images/2023/05/09/oxnbyn.png" width="70%" height="80%">
<img src="https://www.helloimg.com/images/2023/05/09/oxnMmR.png" width="100%" height="20%">

<p>不给参数时就会调用无参构造函数，给参数则会调用带参构造函数<br>！！！！<br>注意事项：<br>① 构造函数是特殊的，不是常规的成员函数，不能直接调 </p>
<p>d1.Date();</p>
<p>② 如果通过无参构造函数创建对象，对象后面不用跟括号，否则就成了函数声明。</p>
<img src="https://www.helloimg.com/images/2023/05/09/oxn2cz.png" width="70%" height="80%">

<p>③ 这里如果调用带参构造函数，我们需要传递三个参数（这里我们没设缺省） 。<br>④ 如果你没有自己定义构造函数（类中未显式定义），C++ 编译器会自动生成一个无参的默认构造函数。当然，如果你自己定义了，编译器就不会帮你生成了。<br><img src="https://www.helloimg.com/images/2023/05/09/oxnTVA.png" width="60%" height="80%"></p>
<p>输出：</p>
<img src="https://www.helloimg.com/images/2023/05/09/oxn9X5.png" width="80%" height="20%">

<h2 id="默认构造函数："><a href="#默认构造函数：" class="headerlink" title="默认构造函数："></a>默认构造函数：</h2><p>任何一个类的默认构造函数，只有三种：<br>① 无参的构造函数<br>② 全缺省的构造函数<br>③ 我们不写，编译器自己生成的构造函数<br>并且默认构造函数只能有一个！<br>注意事项：<br>① 无参构造函数、全缺省构造函数、我们没写编译器默认生成的无参构造函数，都可以认为是默认成员函数。<br>② 语法上无参和全缺省可以同时存在，但如果同时存在会引发二义性：<br>可以同时存在，但是不能调用构造函数否则报错</p>
<p>无参构造函数，全缺省构造函数：</p>
<img src="https://www.helloimg.com/images/2023/05/09/oxnc8m.png" width="70%" height="40%">

<p>举例：</p>
<img src="https://s1.imagehub.cc/images/2023/05/09/image.png" width="70%" height="80%">

<img src="https://www.helloimg.com/images/2023/05/09/oxnsrY.png" width="70%" height="80%">]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基本引用</title>
    <url>/Stouyx/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="实际上是起别名"><a href="#实际上是起别名" class="headerlink" title="实际上是起别名"></a>实际上是起别名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1001;</span><br><span class="line">int &amp;b = a;</span><br><span class="line">b=1002</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">//输出为1002；</span><br></pre></td></tr></table></figure>

<h2 id="用在形参："><a href="#用在形参：" class="headerlink" title="用在形参："></a>用在形参：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void change(int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	b=1003;</span><br><span class="line">&#125;</span><br><span class="line">int a=1001;</span><br><span class="line">change(a);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">//输出为1003；</span><br></pre></td></tr></table></figure>
<h2 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class mm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; getname()</span><br><span class="line">	&#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mm a;</span><br><span class="line">a.getname()=&quot;Tom&quot;</span><br><span class="line">//此时a中的name 为Tom</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/Stouyx/2023/05/23/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数</title>
    <url>/Stouyx/2023/05/15/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>C++中的虚函数是用于实现多态性的一种机制。虚函数可以在基类中声明并在派生类中重写，当通过基类指针或引用调用虚函数时，实际调用的是派生类中的实现，这种行为被称为动态绑定。</p>
<h2 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h2><p>允许派生类重写基类中定义的函数。在基类中声明虚函数，如果派生类中有同名函数并且使用了关键字 virtual 进行了声明，那么这个函数就是虚函数，可以被派生类重写。<br>实现动态绑定。如果使用基类指针或引用调用虚函数，实际上调用的是指向对象的实际类型所实现的版本，而不是基类中的版本。这使得程序能够以一种更加灵活的方式使用对象，可以在运行时动态地确定调用哪个函数。<br>虚函数的应用广泛，特别是在面向对象程序设计中，常常被用来实现多态性和基于接口的编程，提高了程序的可扩展性和可维护性。<br>虚函数用于弥补覆盖的缺陷<br>对函数进行覆盖后，在基类中调用覆盖后的函数还是会调用基类中的函数，<br>但是当基类中的函数为虚函数，那么将调用子类中的覆盖后的函数</p>
<h2 id="虚函数的定义"><a href="#虚函数的定义" class="headerlink" title="虚函数的定义"></a>虚函数的定义</h2><p>在实现c++多态时会用到虚函数。虚函数使用的其核心目的是通过基类访问派生类定义的函数。所谓虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> base();</span><br><span class="line"> virtual void test(); //定义的一个虚函数</span><br><span class="line">private:</span><br><span class="line"> char *basePStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码在基类中定义了一个test的虚函数，所有可以在其子类重新定义父类的做法这种行为成为覆盖（override）,或者为重写。</p>
<p>常见用法：声明基类指针，利用指针指向任意一个子类对象，调用相关的虚函数，动态绑定，由于编写代码时不能确定被调用的是基类函数还是那个派生类函数，所以被称为“”虚“”函数。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>定义：</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 &#x3D;0:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual void funtion1()=0</span><br></pre></td></tr></table></figure>
<p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()&#x3D; 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/Stouyx/2023/05/15/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>当我们编写一个类时，发现这个类与类外一个类的成员变量和成员方法相似，并且具有一定的包含关系时，我们编写的这两个类会有很多相似的地方。</p>
<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>继承机制是面向对象程序设计使代码可以复用的重要手段。它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的类称为派生类。</p>
<p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承使类设计层次的复用。</p>
<p>简单来说就是，继承就是一个类复用了另外一个类的成员函数和成员变量。就好像在这个类里编写了另外一个类的成员。</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEb7F9.png" width="90%" height="50%">


<img src="https://www.helloimg.com/images/2023/05/15/oEbDnX.png" width="90%" height="50%">


<img src="https://www.helloimg.com/images/2023/05/15/oEbIzg.png" width="90%" height="30%">


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基类的私有成员在派生类中不可以见，基类的其它成员在派生类中的访问方式是：继承方式和基类该成员访问限定符范围那个小，就是什么访问方式，等价于min(继承方式，基类该成员访问限定符)。范围从大到小：public &gt; protected &gt; private</p>
<p>基类的private成员，无论以什么继承方式继承，在派生类里是不可以访问的。但是，派生类还是继承了基类，只是在语法上限制了派生类在类里或者类外对基类私有成员的访问。</p>
<p>基类protected成员，通过public或者protected继承方式继承的派生类，该成员变成了派生类的protected成员，只能在类里访问，不能在类外访问。但是基类的private成员，派生类不可见，在继承中体现了两者的区别。可以看出保护成员限定符因继承才出现的。</p>
<p>使用关键字class定义的类的默认继承方式是private，使用关键字struct定义的类的默认继承方式是public，但是，最后显示写出继承方式。<br>在实际运用中一般使用public继承，很少用protected和private继承。因为protected和private继承下来的成员只能在派生类中使用，实用性不强。</p>
<h2 id="基类和派生类对象的赋值转化"><a href="#基类和派生类对象的赋值转化" class="headerlink" title="基类和派生类对象的赋值转化"></a>基类和派生类对象的赋值转化</h2><p>派生类可以给基类赋值<br>派生类对象可以赋值给基类对象&#x2F;基类指针&#x2F;基类引用。这里有一个形象的说法是切片或者切割，意思是将派生类父类中的那部分切来赋值过去。</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEbKtP.png" width="90%" height="80%">


<img src="https://www.helloimg.com/images/2023/05/15/oEbUv6.png" width="90%" height="30%">

<p>基类对象不能赋值给派生类对象。因为基类对象中可能没有派生类中的成员，所以赋值不过去。<br>但是当一个基类指针指向派生类时，可以通过强制类型转化赋值给派生类指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">	string _name; // 姓名</span><br><span class="line">	string _sex; // 性别</span><br><span class="line">	int _age; // 年龄</span><br><span class="line">&#125;;</span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int _No; // 学号</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	Student s;</span><br><span class="line">	// 1.子类对象可以赋值给父类对象/指针/引用</span><br><span class="line">	Person p1 = s;</span><br><span class="line">	Person* pp = &amp;s;</span><br><span class="line">	Person&amp; rp = s;</span><br><span class="line"> </span><br><span class="line">	//2.基类对象不能赋值给派生类对象，会报错</span><br><span class="line">	s = p1;</span><br><span class="line"> </span><br><span class="line">	// 3.基类的指针可以通过强制类型转换赋值给派生类的指针</span><br><span class="line">    //前提，指向基类指针指向派生类</span><br><span class="line">	pp = &amp;s;</span><br><span class="line">	Student* ps1 = (Student*)pp; // 这种情况转换时可以的。</span><br><span class="line">	ps1-&gt;_No = 10;</span><br><span class="line">	//基类指针指向基类的话</span><br><span class="line">	pp = &amp;p1;</span><br><span class="line">	Student* ps2 = (Student*)pp; // 这种情况转换时虽然可以，但是会存在越界访问的问题，</span><br><span class="line">	//由于基类中没有_NO成员，访问会越界</span><br><span class="line">	ps2-&gt;_No = 10;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>在继承体系中基类和派生类具有独立的作用域。</p>
<p>派生类和基类具有同名成员(成员变量和成员函数)时，派生类将屏蔽对父类同名成员的直接访问，这种情况叫隐藏(重定义)。除非指定作用域：基类名 : : 基类成员 (显示访问)</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEbgfn.png" width="90%" height="40%">



<p>如果基类与派生类有同名函数，那么基类的同名函数将会被隐藏，在调用函数的时候，基类函数无法被调用，只能调用派生类的函数（传参不同也不可，函数隐藏不同于函数重载）</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEbrqR.png" width="60%" height="60%">


<img src="https://www.helloimg.com/images/2023/05/15/oEbVTz.png" width="90%" height="40%">

<p>注意：在实际的继承体系同最好不要定义同名成员。</p>
<h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><p>派生类的构造函数必须去调用基类的构造函数去初始化基类的那一部分成员。如果基类没有默认构造函数(无参，全缺省或者编译器生成)，必须在派生类构造函数中显示调用基类的构造函数。<br>有参数的子类构造函数必须调用父类构造函数<br>&lt;子类名&gt;::&lt;子类名&gt;(参数列表):父类名(参数列表)<br>{<br>    成员&#x3D;形参<br>}</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>派生类的拷贝构造函数必须调用基类的拷贝构造函数完成属于基类成员的拷贝构造。</p>
<p>派生类的赋值操作符重载函数(operator&#x3D;)必须调用基类的赋值操作符重载函数(operator&#x3D;)赋值属于基类的成员。<br>注意：在派生类里调用基类的赋值重载函数要加类作用域限定符。</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEbYUA.png" width="90%" height="40%">

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>派生类先调用基类的构造，再调用派生类的构造。<br>派生类对象析构，先调用派生类的析构，再调用基类的析构。</p>
<h2 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h2><p>基类友元的关系，派生类不能继承下来。也就是说基类的友元不能访问派生类的私有和保护成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student;//声明</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend void Print(Person&amp; p, Student&amp; s);//友元</span><br><span class="line">protected:</span><br><span class="line">	string _name = &quot;tom&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Student :public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //friend void Print(Person&amp; p, Student&amp; s);解决</span><br><span class="line">protected:</span><br><span class="line">	int _age = 10;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void Print(Person&amp; p, Student&amp; s)&#123;</span><br><span class="line">	cout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt; s._age &lt;&lt; endl;</span><br><span class="line">	//报错，友元不能继承，不能访问派生类的保护成员</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	Print(p, s);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p> 基类定义了一个静态成员，在继承体系中，只有这一个成员。也就是说，无论派生了多少派生类，操作的这个静态成员都是一个成员。</p>
<img src="https://www.helloimg.com/images/2023/05/15/oEbhP5.png" width="40%" height="100%">


<img src="https://s1.imagehub.cc/images/2023/05/15/image.png" width="90%" height="40%">



]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输入一行整数</title>
    <url>/Stouyx/2023/05/22/%E8%BE%93%E5%85%A5%E4%B8%80%E8%A1%8C%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num;</span><br><span class="line">int m[10000];</span><br><span class="line">int i=0;</span><br><span class="line">while (cin &gt;&gt; num) &#123;</span><br><span class="line">     m[i]=num;</span><br><span class="line">     i++;</span><br><span class="line">     if (cin.get() == &#x27;\n&#x27;) &#123;</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体深入理解cin函数</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>静态成员函数</title>
    <url>/Stouyx/2023/05/08/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>静态成员函数的声明也很简单，就是在类的成员函数前加上static关键字即可，和静态成员一样，静态成员函数也是属于类的，它并不属于任何对象，当调用静态成员函数时应该使用类名和域运算符“∷”，当然也可以使用对象调用操作，但是这样的操作并不意味着静态成员函数属于这个对象，它只是被这个对象共享而已，这样也就决定了静态成员函数中是不能访问本类中的非静态数据成员的，它是不能访问非静态数据成员的，在c++中静态成员函数主要用来访问静态数据成员而不访问非静态数据成员</p>
<p>ps：<br>static int count()<br>name.count()<br>不表示count()属于name</p>
<p>1.静态成员函数不能调用非静态成员函数，但是反过来是可以的</p>
<p>2.静态成员函数没有this指针，也就是说静态成员函数不能使用修饰符(也就是函数后面的const关键字)</p>
<p>3.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用 类成员函数指针来储存。</p>
<p>总结：其实声明为静态，不论是静态数据成员还是静态成员函数，它们都是不依赖于对象而存在的，类在定义后并不分配存储空间，而是在定义类的对象的时候才分配存储空间，相反静态的数据成员和静态的成员函数是已经在内存中开辟了内存空间了，所以静态数据成员可以独立的访问在任何类对象没有建立起来都可以访问，并且静态成员函数不可以调用非静态成员函数，因为非静态成员函数只有在类对象建立以后才可以调用，相反则是可以的。<br><img src="https://www.helloimg.com/images/2023/05/09/oxnXZC.png" width="100%" height="100%"></p>
<h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>对象的成员函数（没有static的成员函数）内部，可以直接访问“静态数据成员”<br>类的静态成员函数（有static的成员函数）内部，可以直接访问“静态数据成员”<br>即：所有的成员函数，都可以访问静态数据成员。<br>类不能直接访问普通的静态数据成员（Human::humanCount 非法）</p>
<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>对象可以直接访问静态成员函数<br>类可以直接访问静态成员函数（Human::getHumanCount()）<br>在类的静态成员函数（类的静态方法）内部，不能直接访问this指针和对象的数据成员！<br>在类的静态成员函数（类的静态方法）内部，只能访问类的数据成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义Student类</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Student                  </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//定义构造函数</span><br><span class="line">Student(int n,int a,float s):num(n),age(a),score(s)&#123; &#125;      </span><br><span class="line">void total();</span><br><span class="line">//声明静态成员函数</span><br><span class="line">static float average();      </span><br><span class="line">private:</span><br><span class="line">    int num;</span><br><span class="line">    int age;</span><br><span class="line">    float score;</span><br><span class="line">    //静态数据成员，累计学生的总分</span><br><span class="line">    static float sum; </span><br><span class="line">    //静态数据成员，累计学生的人数</span><br><span class="line">    static int count;           </span><br><span class="line">&#125;;</span><br><span class="line">//在全局作用域对静态数据成员初始化，如果不赋予初值，则使用其默认值零</span><br><span class="line">float Student::sum;                     </span><br><span class="line">int Student::count;</span><br><span class="line">//定义非静态成员函数</span><br><span class="line">void Student::total()                    </span><br><span class="line">&#123;</span><br><span class="line">    //累加总分</span><br><span class="line">    sum+=score;</span><br><span class="line">    //累计已统计的人数</span><br><span class="line">    count++;                               </span><br><span class="line">&#125;</span><br><span class="line">//定义静态成员函数</span><br><span class="line">float  Student::average()                  </span><br><span class="line">&#123;</span><br><span class="line">    return(sum/count);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Student stud[3]=&#123;    </span><br><span class="line">    //定义对象数组并初始化</span><br><span class="line">    Student(1001,18,70),</span><br><span class="line">    Student(1002,19,78),</span><br><span class="line">    Student(1005,20,98)</span><br><span class="line">&#125;;</span><br><span class="line">int n;</span><br><span class="line">std::cout&lt;&lt;&quot;please input the number of students: &quot;;</span><br><span class="line"> //输入需要求前面多少名学生的平均成绩</span><br><span class="line">std::cin&gt;&gt;n;                              </span><br><span class="line">//调用3次total函数</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    stud[i].total();</span><br><span class="line">&#125;</span><br><span class="line">//调用静态成员函数</span><br><span class="line">std::cout&lt;&lt;&quot;the average score of &quot;&lt;&lt;n&lt;&lt;&quot; students is &quot;&lt;&lt;Student::average( )&lt;&lt;std::endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>隐藏重载覆盖</title>
    <url>/Stouyx/2023/05/09/%E9%9A%90%E8%97%8F%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<p>存在父子类继承关系时，若有同名成员函数同时存在，会发生隐藏、覆盖和重载这几种情况。</p>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>子类对象优先考虑子类域自身成员（成员变量和成员函数）<br>    隐藏发生的主要原因，就是当子类有父类的同名成员时，子类对象访问该成员时，会发生冲突。所以编译器的处理方式是，优先考虑子类域中的自身成员。即，子类对象访问某成员时，如ch.m_m 或者ch.f(),成员变量和成员函数都一样。编译器首先在子类域中检索，如果在子类域中找到该成员，则检索结束，返回该成员进行访问。如果在子类域中找不到该成员，则去父类域中检索。如果父类域中存在，则返回该成员进行访问，如果父类域中也不存在，则编译错误，该成员无效。</p>
<p>  当父子类域都存在同一成员时，编译器优先在子类中检索，就算父类域中也存在该同名成员，也不会被检索到。因此，父类域中的该成员被子类域中的该同名成员隐藏，即访问时完全以为该成员不存在，如果想访问父类域中的该成员，只能通过显示调用的方式，即：ch.Father::m_m;<br>重载：相同域的同名不同参函数</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>　　<br>　　重载必须是发生在同一个域中的两个同名不同形参之间的。如果一个在父类域一个在子类域，是不会存在重载的，属于隐藏的情况。调用时，只会在子类域中搜索，如果形参不符合，会认为没有该函数，而不会去父类域中搜索。<br>覆盖是指派生类函数覆盖基类函数，特征是：<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有virtual 关键字。<br>令人迷惑的隐藏规则<br>本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。<br>这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：<br>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual<br>关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual<br>关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/Stouyx/2023/05/08/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="不能重载的运算符："><a href="#不能重载的运算符：" class="headerlink" title="不能重载的运算符："></a>不能重载的运算符：</h2><img src="https://www.helloimg.com/images/2023/05/09/oxnnSP.png" width="100%" height="100%">

<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>模板为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people operator = (const people &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	delete [] char*;</span><br><span class="line">	赋值；</span><br><span class="line">	return *this</span><br><span class="line">&#125;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">class HugeInteger&#123;</span><br><span class="line">public:</span><br><span class="line">	HugeInteger&amp; operator=(const HugeInteger &amp;h);</span><br><span class="line">private:</span><br><span class="line">    string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HugeInteger&amp; HugeInteger::operator=(const HugeInteger &amp;h)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;str=h.str;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算术运算符的重载"><a href="#算术运算符的重载" class="headerlink" title="算术运算符的重载"></a>算术运算符的重载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people operator + (const people &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	people b;</span><br><span class="line">	b.r=r+a.r;</span><br><span class="line">	return b;</span><br><span class="line">&#125;</span><br><span class="line">+、++、–、- -、+=、-=、/、*</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class complex&#123;</span><br><span class="line">public:</span><br><span class="line">    complex(double r=0,double i=0)&#123;</span><br><span class="line">        this-&gt;r=r;</span><br><span class="line">        this-&gt;i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    complex operator+(complex&amp;);</span><br><span class="line">    complex operator-(complex&amp;);</span><br><span class="line">    complex operator+=(complex&amp;);</span><br><span class="line">private:</span><br><span class="line">    double r, i;</span><br><span class="line">&#125;;</span><br><span class="line">complex complex::operator+(complex &amp;c)&#123;</span><br><span class="line">    return complex(r+c.r,i+c.i);</span><br><span class="line">&#125;</span><br><span class="line">complex complex::operator-(complex &amp;c)&#123;</span><br><span class="line">    return complex(r-c.r,i-c.i);</span><br><span class="line">&#125;</span><br><span class="line">complex complex::operator+=(complex &amp;c)&#123;</span><br><span class="line">    r+=c.r;</span><br><span class="line">    i+=c.i;</span><br><span class="line">    return *this;//return complex(r,i)亦可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符的重载"><a href="#关系运算符的重载" class="headerlink" title="关系运算符的重载"></a>关系运算符的重载</h2><p>模板为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool people:: operator == (const people &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">	if()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">#include &lt;cstring&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    string str;   </span><br><span class="line">public:</span><br><span class="line">	String(string s)&#123;str=s;&#125;</span><br><span class="line">	friend bool operator&gt;(const String &amp;st1, const String &amp;st2);</span><br><span class="line">	friend bool operator==(const String &amp;st, const String &amp;st2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator&gt;(const String &amp;st1, const String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">    return (std::strcmp(st1.str, st2.str) &gt; 0);</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(const String &amp;st1, const String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">    return (std::strcmp(st1.str, st2.str) == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单目运算符："><a href="#单目运算符：" class="headerlink" title="单目运算符："></a>单目运算符：</h2><p>单目运算符只作用于当前对象所以不需要传参<br>前置++：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people operator ++ ()</span><br><span class="line">&#123;</span><br><span class="line">	++r;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置++：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people operator ++ (int)</span><br><span class="line">&#123;</span><br><span class="line">	people a(r);    用当前对象的数据初始化a</span><br><span class="line">	</span><br><span class="line">	a.r++;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在这里给出重载&lt;&lt;,&gt;&gt;,[]的方法<br>模板：<br>(1)cout&lt;&lt;：<br>friend ostream &amp;operator&lt;&lt;(ostream &amp;cout，const classname&amp; 实例对象) &#x2F; ostream &amp;operator&lt;&lt;(ostream &amp;cout)<br>(2)cin&gt;&gt;：friend istream &amp;operator&gt;&gt;(istream &amp;cin，classname&amp; 实例对象) &#x2F; istream &amp;operator&gt;&gt;(istream &amp;cin)<br>(3)[ ]：typename &amp; operator[ ] (形参表)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">#include &lt;cstring&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    string str;   </span><br><span class="line">public:</span><br><span class="line">	String(string s)&#123;str=s;&#125;</span><br><span class="line">	char &amp; operator[](int i);</span><br><span class="line">	friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const String &amp; st);</span><br><span class="line">    friend istream &amp; operator&gt;&gt;(istream &amp; cin, String &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char &amp;String::operator[](int i)</span><br><span class="line">&#123;</span><br><span class="line">    return str[i];</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp; cout, const String &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; st.str;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;operator&gt;&gt;(istream &amp; cin, String &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">    char temp[40];</span><br><span class="line">    is.get(temp, 40);</span><br><span class="line">    if (cin)</span><br><span class="line">        st = temp;</span><br><span class="line">    while (cin &amp;&amp; cin.get() != &#x27;\n&#x27;)</span><br><span class="line">        continue;</span><br><span class="line">    return cin;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; operator&gt;&gt;(istream&amp; ins,_Point&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">        //输入到两个变量里面</span><br><span class="line">        ins&gt;&gt;target.x&gt;&gt;target.y;</span><br><span class="line">        return ins;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>new的理解</title>
    <url>/Stouyx/2023/11/28/new%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><h2 id="1-new可以直接返回一个指针"><a href="#1-new可以直接返回一个指针" class="headerlink" title="1.new可以直接返回一个指针"></a>1.new可以直接返回一个指针</h2><p>如果已经有一个 HuffmanNode 对象，可以创建指向它的指针，无需使用 new：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HuffmanNode node(10);  // 创建一个 HuffmanNode 对象</span><br><span class="line">HuffmanNode* pointer = &amp;node;  // 创建指向该对象的指针</span><br></pre></td></tr></table></figure>

<p>这里 pointer 是一个指向 node 对象的指针，而不是使用 new 分配内存创建的指针</p>
<p>如果要创建一个新的对象并且获得指向它的指针，通常情况下可以使用 new 操作符来动态分配内存并创建对象。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HuffmanNode* newNode = new HuffmanNode(20); </span><br></pre></td></tr></table></figure>

<p>这行代码会在堆内存中分配空间以存储一个 HuffmanNode 对象，并将其初始化为权值为 20，然后返回指向这个对象的指针 newNode<br>但是，在使用 new 创建对象后，务必记得在不需要这个对象时使用 delete 删除释放它所占用的内存，以免造成内存泄漏</p>
<h2 id="2-函数中new出来的变量可以跨函数使用"><a href="#2-函数中new出来的变量可以跨函数使用" class="headerlink" title="2.函数中new出来的变量可以跨函数使用"></a>2.函数中new出来的变量可以跨函数使用</h2><p>在函数中直接使用变量名声明的变量通常是局部变量，它们的作用域限定在该函数内部。一旦函数执行结束，这些局部变量所占用的内存空间会被释放掉，它们的生命周期也随之结束。</p>
<p>例如，在函数中这样声明变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void myFunction() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当myFunction()执行完毕后，变量x将会被销毁，因为它是在函数内部声明的局部变量。这种变量的生命周期通常是在其所在的代码块结束时结束。</p>
<p>对于动态分配的内存，比如使用new来分配内存，所分配的内存空间并不会在函数结束时自动释放，而是需要显式地使用delete来释放。使用 new 运算符在堆（heap）上动态分配的内存空间可以跨函数使用。堆上分配的内存空间不受局部作用域的限制。这种情况下，即使函数结束，分配的内存仍然存在，除非显式释放。</p>
<p>因此，直接在函数中声明的变量，一般在函数结束时会被销毁。而使用动态分配内存的变量（通过new操作符），则需要手动释放分配的内存空间，否则可能会导致内存泄漏。</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径</title>
    <url>/Stouyx/2023/12/04/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<img src="https://vip.helloimg.com/images/2023/12/04/oQdUpK.jpg" width="900%" height="100%">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int graph[][9], int weight[][9], int start, int end) &#123;</span><br><span class="line">    int dis[9];</span><br><span class="line">    int pre[9];</span><br><span class="line">    bool flag[9];</span><br><span class="line"></span><br><span class="line">    // 初始化数组</span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        dis[i] = INT_MAX;</span><br><span class="line">        pre[i] = -1;</span><br><span class="line">        flag[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[start] = 0;</span><br><span class="line">    flag[start] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        if (graph[start][i] == 1) &#123;</span><br><span class="line">            dis[i] = weight[start][i];</span><br><span class="line">            pre[i] = start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">        int min = INT_MAX;</span><br><span class="line">        int min_rode = -1;</span><br><span class="line"></span><br><span class="line">        // 在没有最短路径标记的点中找到距离最小的节点</span><br><span class="line">        for (int j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">            if (!flag[j] &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                min_rode = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到路径最小点之后 遍历最小点的邻接点</span><br><span class="line">        if (min_rode != -1) &#123;</span><br><span class="line">            flag[min_rode] = true;</span><br><span class="line">            for (int k = 0; k &lt; 9; k++) &#123;</span><br><span class="line">                if (!flag[k] &amp;&amp; graph[min_rode][k] == 1 &amp;&amp; dis[min_rode] + weight[min_rode][k] &lt; dis[k]) &#123;</span><br><span class="line">                    dis[k] = dis[min_rode] + weight[min_rode][k];</span><br><span class="line">                    pre[k] = min_rode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出最短路径</span><br><span class="line">    cout &lt;&lt; &quot;从节点 &quot; &lt;&lt; start &lt;&lt; &quot; 到节点 &quot; &lt;&lt; end &lt;&lt; &quot; 的最短路径为：&quot; &lt;&lt; dis[end] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int graph[9][9] = &#123;</span><br><span class="line">        &#123;0, 1, 0, 0, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">        &#123;1, 0, 1, 0, 0, 0, 0, 1, 0&#125;,</span><br><span class="line">        &#123;0, 1, 0, 1, 0, 1, 0, 0, 1&#125;,</span><br><span class="line">        &#123;0, 0, 1, 0, 1, 1, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 1, 0, 1, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 1, 1, 1, 0, 1, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 0, 0, 1, 0, 1, 1&#125;,</span><br><span class="line">        &#123;1, 1, 0, 0, 0, 0, 1, 0, 1&#125;,</span><br><span class="line">        &#123;0, 0, 1, 0, 0, 0, 1, 1, 0&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    int weight[9][9] = &#123;</span><br><span class="line">        &#123;0, 4, 0, 0, 0, 0, 0, 8, 0&#125;,</span><br><span class="line">        &#123;4, 0, 8, 0, 0, 0, 0, 11, 0&#125;,</span><br><span class="line">        &#123;0, 8, 0, 7, 0, 4, 0, 0, 2&#125;,</span><br><span class="line">        &#123;0, 0, 7, 0, 9, 14, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 9, 0, 10, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 4, 14, 10, 0, 2, 0, 0&#125;,</span><br><span class="line">        &#123;0, 0, 0, 0, 0, 2, 0, 1, 6&#125;,</span><br><span class="line">        &#123;8, 11, 0, 0, 0, 0, 1, 0, 7&#125;,</span><br><span class="line">        &#123;0, 0, 2, 0, 0, 0, 6, 7, 0&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = 4;</span><br><span class="line"></span><br><span class="line">    Dijkstra(graph, weight, start, end);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimax算法</title>
    <url>/Stouyx/2023/12/04/Minimax/</url>
    <content><![CDATA[<h1 id="算法具体内容"><a href="#算法具体内容" class="headerlink" title="算法具体内容"></a>算法具体内容</h1><p>Minimax算法是一种常用于回合制游戏的决策树搜索算法，用于在有限的游戏状态树中找到最佳决策。它通过递归地评估游戏状态来模拟所有可能的走法，最大化自己的利益并最小化对手的利益。</p>
<p>该算法基于以下两个基本概念：</p>
<p>Maximize（最大化）： 在玩家自己的回合，尝试选择最有利于自己的走法。</p>
<p>Minimize（最小化）： 在对手的回合，尝试选择最不利于自己的走法，即最有利于对手的走法。</p>
<p>Minimax算法的核心思想是递归地生成游戏状态树，并根据当前玩家的角色（最大化还是最小化）来选择对应的最优走法。它通过评估每个可能的走法，并选择能够导致最有利结果的走法。</p>
<p>在实现Minimax算法时，通常会使用递归函数来模拟游戏状态的展开和评估。在棋类游戏中，例如井字棋，算法会评估每一步可能的移动，计算最终的得分，并选择能够最大化当前玩家利益的最佳走法。<br>Minimax算法通常用于模拟两个对手轮流进行决策的情况，默认自己为其中一个选手，而另一个为对手，其中一个玩家会尽力最大化自己的得分（Maximizer），而另一个玩家会尽力最小化对手的得分（Minimizer）。</p>
<p>在典型的Minimax算法中：</p>
<p>最大化玩家（Maximizer）努力寻找可以让自己得分最高的决策，即通过递归调用找到最大值。</p>
<p>最小化玩家（Minimizer）则努力寻找可以让最大化玩家得分最低的决策，即通过递归调用找到最小值。</p>
<p>在Minimax算法中，使用递归进行状态树的搜索，即尝试模拟每一个可能的走法，评估每个走法对最终结果的影响。为了模拟这些可能的走法，必须在递归调用中修改棋盘的状态，即将某个位置设置为当前玩家的棋子。但在递归调用结束后，需要将棋盘状态恢复，以便尝试其他可能的走法。</p>
<p>回溯确保了算法能够尝试所有可能的走法，并且在搜索完一条分支后，能够回到上一个状态，尝试其他分支。如果不进行回溯，可能会导致算法在搜索时无法正确模拟所有可能的情况，影响最终得出的最优决策。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Alice和Bob正在玩井字棋游戏。 井字棋游戏的规则很简单：两人轮流往3*3的棋盘中放棋子，Alice放的是“X”，Bob放的是“O”，Alice执先。当同一种棋子占据一行、一列或一条对角线的三个格子时，游戏结束，该种棋子的持有者获胜。当棋盘被填满的时候，游戏结束，双方平手。 <br>　　Alice设计了一种对棋局评分的方法： <br>　　- 对于Alice已经获胜的局面，评估得分为(棋盘上的空格子数+1)； <br>　　- 对于Bob已经获胜的局面，评估得分为 -(棋盘上的空格子数+1)； <br>　　- 对于平局的局面，评估得分为0；<br>　　例如上图中的局面，Alice已经获胜，同时棋盘上有2个空格，所以局面得分为2+1&#x3D;3。 <br>　　由于Alice并不喜欢计算，所以他请教擅长编程的你，如果两人都以最优策略行棋，那么当前局面的最终得分会是多少？ <br>csp 棋局评估</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;climits&gt; // 引入 INT_MAX</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line">int G[N][N]; // 井字棋盘面</span><br><span class="line"></span><br><span class="line">// 检查某个玩家是否胜利</span><br><span class="line">bool check(int player) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        // 检查行和列</span><br><span class="line">        if (G[i][0] == player &amp;&amp; G[i][1] == player &amp;&amp; G[i][2] == player) return true; // 检查行</span><br><span class="line">        if (G[0][i] == player &amp;&amp; G[1][i] == player &amp;&amp; G[2][i] == player) return true; // 检查列</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查对角线</span><br><span class="line">    if (G[0][0] == player &amp;&amp; G[1][1] == player &amp;&amp; G[2][2] == player) return true; // 检查对角线</span><br><span class="line">    if (G[0][2] == player &amp;&amp; G[1][1] == player &amp;&amp; G[2][0] == player) return true; // 检查对角线</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 评估当前局面得分</span><br><span class="line">int evaluate() &#123;</span><br><span class="line">    int emptySpaces = 0;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++)</span><br><span class="line">        for (int j = 0; j &lt; 3; j++)</span><br><span class="line">            if (G[i][j] == 0) emptySpaces++; // 统计剩余空格数</span><br><span class="line"></span><br><span class="line">    if (check(1)) return emptySpaces + 1; // 玩家 A 获胜</span><br><span class="line">    else if (check(2)) return -(emptySpaces + 1); // 玩家 B 获胜</span><br><span class="line">    else if (emptySpaces == 0) return 0; // 平局</span><br><span class="line">    else return INT_MAX; // 游戏未结束，使用 INT_MAX 表示无穷大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 Minimax 和 DFS 来计算局面得分</span><br><span class="line">int minimax(int player) &#123;</span><br><span class="line">    int score = evaluate();</span><br><span class="line">    if (score != INT_MAX) return score; // 已经可以确定胜负或平局，直接返回得分</span><br><span class="line"></span><br><span class="line">    if (player == 1) &#123;</span><br><span class="line">        int ans = -INT_MAX;</span><br><span class="line">        // 遍历所有可能的下一步走法</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (G[i][j] == 0) &#123; // 空格可以下子</span><br><span class="line">                    G[i][j] = 1; // 假设下子</span><br><span class="line">                    ans = max(ans, minimax(2)); // 递归调用，选取对手最差的情况</span><br><span class="line">                    G[i][j] = 0; // 回溯，恢复空格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        // 遍历所有可能的下一步走法</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (G[i][j] == 0) &#123; // 空格可以下子</span><br><span class="line">                    G[i][j] = 2; // 假设下子</span><br><span class="line">                    ans = min(ans, minimax(1)); // 递归调用，选取对手最好的情况</span><br><span class="line">                    G[i][j] = 0; // 回溯，恢复空格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        // 读入当前局面</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            for (int j = 0; j &lt; 3; j++)</span><br><span class="line">                cin &gt;&gt; G[i][j];</span><br><span class="line"></span><br><span class="line">        int res = minimax(1); // 玩家 A 先走</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树算法</title>
    <url>/Stouyx/2023/12/04/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>Prim算法是一种用来构建最小生成树的贪婪算法，通常用于带有权重的连通图中。它从一个初始顶点开始，逐步扩展最小生成树，每次选择连接已选定顶点集合和未选定顶点集合的边中权重最小的边，将新的顶点加入已选定的顶点集合，直到所有顶点都被包含在最小生成树中。</p>
<p>Prim算法的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prim(G, d[])</span><br><span class="line">&#123;</span><br><span class="line">	初始化;</span><br><span class="line">	for(循环n次)</span><br><span class="line">	&#123;</span><br><span class="line">		u = 使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">		记u已被访问;</span><br><span class="line">		for(从u出发能到达的所有顶点v)</span><br><span class="line">		&#123;</span><br><span class="line">			if(v未被访问 &amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)</span><br><span class="line">			&#123;</span><br><span class="line">				将G[u][v]赋值给v与集合S的最短距离d[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define V 5 // 假设图有5个顶点</span><br><span class="line"></span><br><span class="line">int minKey(int key[], bool mstSet[]) &#123;</span><br><span class="line">    int min = INT_MAX, min_index;</span><br><span class="line"></span><br><span class="line">    for (int v = 0; v &lt; V; v++) &#123;</span><br><span class="line">        if (mstSet[v] == false &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            min = key[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printMST(int parent[], int graph[V][V]) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;边\t权重\n&quot;;</span><br><span class="line">    for (int i = 1; i &lt; V; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; &quot; - &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; graph[i][parent[i]] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void primMST(int graph[V][V]) &#123;</span><br><span class="line">    int parent[V]; // 存放构建的最小生成树</span><br><span class="line">    int key[V]; // 存放选择的顶点到最小生成树的最小权重</span><br><span class="line"></span><br><span class="line">    bool mstSet[V]; // 用于判断顶点是否在最小生成树中</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; V; i++) &#123;</span><br><span class="line">        key[i] = INT_MAX;</span><br><span class="line">        mstSet[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key[0] = 0; // 从第一个顶点开始构建</span><br><span class="line"></span><br><span class="line">    parent[0] = -1; // 根节点没有父节点</span><br><span class="line"></span><br><span class="line">    for (int count = 0; count &lt; V - 1; count++) &#123;</span><br><span class="line">        int u = minKey(key, mstSet);</span><br><span class="line"></span><br><span class="line">        mstSet[u] = true;</span><br><span class="line"></span><br><span class="line">        for (int v = 0; v &lt; V; v++) &#123;</span><br><span class="line">            if (graph[u][v] &amp;&amp; mstSet[v] == false &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                key[v] = graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMST(parent, graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int graph[V][V] = &#123;</span><br><span class="line">        &#123;0, 2, 0, 6, 0&#125;,</span><br><span class="line">        &#123;2, 0, 3, 8, 5&#125;,</span><br><span class="line">        &#123;0, 3, 0, 0, 7&#125;,</span><br><span class="line">        &#123;6, 8, 0, 0, 9&#125;,</span><br><span class="line">        &#123;0, 5, 7, 9, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    primMST(graph);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Prim算法可以使用堆或优先队列来存储和处理边的信息，以便快速找到权重最小的边。它的时间复杂度通常为 O(ElogV)，其中 V 是顶点数，E 是边数，这使得Prim算法在处理大型图时效率较高。</p>
<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>Kruskal算法也是用来构建最小生成树的一种贪婪算法，它与Prim算法不同的是，Kruskal算法是基于边来构建最小生成树的。</p>
<p>Kruskal算法的步骤如下：</p>
<p>初始化：将图中的每个顶点看作是一个独立的树（单独的集合），将所有边按照权重从小到大进行排序。</p>
<p>重复以下步骤，直到形成最小生成树：</p>
<p>从已排序的边中选择权重最小的边。<br>如果这条边连接的两个顶点属于不同的树（不在同一个集合中），则将这两个树合并成一棵树，即将这两个顶点所在的集合合并。<br>如果这条边连接的两个顶点已经在同一棵树中，则舍弃这条边，以避免形成环路。<br>当最小生成树中包含了图中的所有顶点时，算法结束。</p>
<p>Kruskal算法不断选择权重最小的边，并通过并查集等数据结构来维护顶点的连通性。它会避免形成环路，并确保生成的树是一个连通树。与Prim算法相比，Kruskal算法不需要选择一个初始顶点，它更侧重于边的选择和集合的合并。</p>
<p>Kruskal算法的时间复杂度通常为 O(ElogE)，其中 E 是边数。它适用于稀疏图（边数相对较少）的情况下，效率较高。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/Stouyx/2024/01/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>文章链接：<br><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/0704.二分查找.html#算法公开课</a></p>
<p>视频链接：<br><a href="https://www.bilibili.com/videoBV1fA4y1o715vd_source=5879d4dbc6634ee4e06bbb59f255d0fa%E3%80%81">https://www.bilibili.com/videoBV1fA4y1o715vd_source=5879d4dbc6634ee4e06bbb59f255d0fa、</a></p>
<p>题目：<br><a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<p>状态：之前只了解过二分查找的过程，上手写才知道有这么多细节需要注意，<br>如果有重复元素的话应该会更复杂</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的边界确定，与数组的定义一一对应，根据数组来确定边界</p>
<h2 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h2><p>[left,right]<br>此时 left 与 right 都在区间中，而且 left &#x3D; right 可以成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0;//包含左区间，从0开始</span><br><span class="line">    int right = nums.size()-1;//包含右区间，从尾下标开始</span><br><span class="line">    while (left&lt;=right) &#123;  </span><br><span class="line">    //left = right 可以成立，所以有等于号</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        if (nums[mid]&lt;target) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">            //包含左边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[mid]&gt;target) &#123;</span><br><span class="line">            right = mid-1;</span><br><span class="line">            //包含右边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h2><p>[left,right)<br>此时 left 在区间中，right 不在区间中，而且 left &#x3D; right 不成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0;//包含左区间，从0开始</span><br><span class="line">    int right = nums.size();//不包含右区间，从尾下标的下一个开始</span><br><span class="line">    while (left&lt;right) &#123;  </span><br><span class="line">    //left = right 不成立，不能有等于号</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        if (nums[mid]&lt;target) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">            //包含左边界，mid不符合条件要剔除</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[mid]&gt;target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            //不包含右边界，所以可以保留mid</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/Stouyx/2024/01/24/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>题目链接：<br><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a> </p>
<p>文章讲解：<br><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</a></p>
<p>视频讲解：<br><a href="https://www.bilibili.com/video/BV12A4y1Z7LP">https://www.bilibili.com/video/BV12A4y1Z7LP</a></p>
<p>状态：第一次看题想要用两层循环去解决</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>时间复杂度O(n^2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i&lt;size; i++) &#123;</span><br><span class="line">            if(nums[i] == val)&#123;</span><br><span class="line">                for (int j = i+1; j&lt;size; j++) &#123;</span><br><span class="line">                //j=i的话 有nums[j] 保证其不越界 j要小于size</span><br><span class="line">                    nums[j-1] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i&lt;size; i++) &#123;</span><br><span class="line">            if(nums[i] == val)&#123;</span><br><span class="line">                for (int j = i; j&lt;size-1; j++) &#123;</span><br><span class="line">                //j=i的话 有nums[j+1] 保证其不越界 j要小于size-1</span><br><span class="line">                    nums[j] = nums[j+1];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>时间复杂度O(n);</p>
<p>快指针用于获取新的数据，然后检查新的数据是否满足要求<br>满足要求的话就赋值给慢指针，然后慢指针后移一位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast&lt;nums.size(); fast++) &#123;</span><br><span class="line">            if(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
